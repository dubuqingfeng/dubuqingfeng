"use strict";(self.webpackChunkdubuqingfeng=self.webpackChunkdubuqingfeng||[]).push([[5439],{99221:(t,n,e)=>{e.r(n),e.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>g,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=e(74848),o=e(28453);const i={},a=void 0,s={id:"Wiki/programming/golang/goroutine/goroutine",title:"goroutine",description:"Goroutine",source:"@site/docs/Wiki/programming/golang/goroutine/goroutine.md",sourceDirName:"Wiki/programming/golang/goroutine",slug:"/Wiki/programming/golang/goroutine/",permalink:"/docs/Wiki/programming/golang/goroutine/",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"gc",permalink:"/docs/Wiki/programming/golang/gc/"},next:{title:"gm",permalink:"/docs/Wiki/programming/golang/goroutine/gm"}},c={},l=[{value:"Goroutine",id:"goroutine",level:3},{value:"G",id:"g",level:4},{value:"\u8c03\u5ea6\u7b56\u7565",id:"\u8c03\u5ea6\u7b56\u7565",level:4}];function u(t){const n={a:"a",code:"code",h3:"h3",h4:"h4",p:"p",pre:"pre",...(0,o.R)(),...t.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h3,{id:"goroutine",children:"Goroutine"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/golang/go/blob/master/src/runtime/runtime2.go",children:"https://github.com/golang/go/blob/master/src/runtime/runtime2.go"})}),"\n",(0,r.jsx)(n.h4,{id:"g",children:"G"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"// G \u7ed3\u6784\u4f53\r\ntype g struct {\r\n\t// Stack parameters.\r\n\t// stack describes the actual stack memory: [stack.lo, stack.hi).\r\n\t// stackguard0 is the stack pointer compared in the Go stack growth prologue.\r\n\t// It is stack.lo+StackGuard normally, but can be StackPreempt to trigger a preemption.\r\n\t// stackguard1 is the stack pointer compared in the C stack growth prologue.\r\n\t// It is stack.lo+StackGuard on g0 and gsignal stacks.\r\n\t// It is ~0 on other goroutine stacks, to trigger a call to morestackc (and crash).\r\n\tstack       stack   // offset known to runtime/cgo\r\n\tstackguard0 uintptr // offset known to liblink\r\n\tstackguard1 uintptr // offset known to liblink\r\n\r\n\t_panic    *_panic // innermost panic - offset known to liblink\r\n\t_defer    *_defer // innermost defer\r\n\tm         *m      // current m; offset known to arm liblink\r\n\tsched     gobuf\r\n\tsyscallsp uintptr // if status==Gsyscall, syscallsp = sched.sp to use during gc\r\n\tsyscallpc uintptr // if status==Gsyscall, syscallpc = sched.pc to use during gc\r\n\tstktopsp  uintptr // expected sp at top of stack, to check in traceback\r\n\t// param is a generic pointer parameter field used to pass\r\n\t// values in particular contexts where other storage for the\r\n\t// parameter would be difficult to find. It is currently used\r\n\t// in three ways:\r\n\t// 1. When a channel operation wakes up a blocked goroutine, it sets param to\r\n\t//    point to the sudog of the completed blocking operation.\r\n\t// 2. By gcAssistAlloc1 to signal back to its caller that the goroutine completed\r\n\t//    the GC cycle. It is unsafe to do so in any other way, because the goroutine's\r\n\t//    stack may have moved in the meantime.\r\n\t// 3. By debugCallWrap to pass parameters to a new goroutine because allocating a\r\n\t//    closure in the runtime is forbidden.\r\n\tparam        unsafe.Pointer\r\n\tatomicstatus uint32\r\n\tstackLock    uint32 // sigprof/scang lock; TODO: fold in to atomicstatus\r\n\tgoid         int64\r\n\tschedlink    guintptr\r\n\twaitsince    int64      // approx time when the g become blocked\r\n\twaitreason   waitReason // if status==Gwaiting\r\n\r\n\tpreempt       bool // preemption signal, duplicates stackguard0 = stackpreempt\r\n\tpreemptStop   bool // transition to _Gpreempted on preemption; otherwise, just deschedule\r\n\tpreemptShrink bool // shrink stack at synchronous safe point\r\n\r\n\t// asyncSafePoint is set if g is stopped at an asynchronous\r\n\t// safe point. This means there are frames on the stack\r\n\t// without precise pointer information.\r\n\tasyncSafePoint bool\r\n\r\n\tpaniconfault bool // panic (instead of crash) on unexpected fault address\r\n\tgcscandone   bool // g has scanned stack; protected by _Gscan bit in status\r\n\tthrowsplit   bool // must not split stack\r\n\t// activeStackChans indicates that there are unlocked channels\r\n\t// pointing into this goroutine's stack. If true, stack\r\n\t// copying needs to acquire channel locks to protect these\r\n\t// areas of the stack.\r\n\tactiveStackChans bool\r\n\t// parkingOnChan indicates that the goroutine is about to\r\n\t// park on a chansend or chanrecv. Used to signal an unsafe point\r\n\t// for stack shrinking. It's a boolean value, but is updated atomically.\r\n\tparkingOnChan uint8\r\n\r\n\traceignore     int8     // ignore race detection events\r\n\tsysblocktraced bool     // StartTrace has emitted EvGoInSyscall about this goroutine\r\n\ttracking       bool     // whether we're tracking this G for sched latency statistics\r\n\ttrackingSeq    uint8    // used to decide whether to track this G\r\n\trunnableStamp  int64    // timestamp of when the G last became runnable, only used when tracking\r\n\trunnableTime   int64    // the amount of time spent runnable, cleared when running, only used when tracking\r\n\tsysexitticks   int64    // cputicks when syscall has returned (for tracing)\r\n\ttraceseq       uint64   // trace event sequencer\r\n\ttracelastp     puintptr // last P emitted an event for this goroutine\r\n\tlockedm        muintptr\r\n\tsig            uint32\r\n\twritebuf       []byte\r\n\tsigcode0       uintptr\r\n\tsigcode1       uintptr\r\n\tsigpc          uintptr\r\n\tgopc           uintptr         // pc of go statement that created this goroutine\r\n\tancestors      *[]ancestorInfo // ancestor information goroutine(s) that created this goroutine (only used if debug.tracebackancestors)\r\n\tstartpc        uintptr         // pc of goroutine function\r\n\tracectx        uintptr\r\n\twaiting        *sudog         // sudog structures this g is waiting on (that have a valid elem ptr); in lock order\r\n\tcgoCtxt        []uintptr      // cgo traceback context\r\n\tlabels         unsafe.Pointer // profiler labels\r\n\ttimer          *timer         // cached timer for time.Sleep\r\n\tselectDone     uint32         // are we participating in a select and did someone win the race?\r\n\r\n\t// goroutineProfiled indicates the status of this goroutine's stack for the\r\n\t// current in-progress goroutine profile\r\n\tgoroutineProfiled goroutineProfileStateHolder\r\n\r\n\t// Per-G GC state\r\n\r\n\t// gcAssistBytes is this G's GC assist credit in terms of\r\n\t// bytes allocated. If this is positive, then the G has credit\r\n\t// to allocate gcAssistBytes bytes without assisting. If this\r\n\t// is negative, then the G must correct this by performing\r\n\t// scan work. We track this in bytes to make it fast to update\r\n\t// and check for debt in the malloc hot path. The assist ratio\r\n\t// determines how this corresponds to scan work debt.\r\n\tgcAssistBytes int64\r\n}\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:'// Machine\r\ntype m struct {\r\n\tg0      *g     // goroutine with scheduling stack\r\n\tmorebuf gobuf  // gobuf arg to morestack\r\n\tdivmod  uint32 // div/mod denominator for arm - known to liblink\r\n\t_       uint32 // align next field to 8 bytes\r\n\r\n\t// Fields not known to debuggers.\r\n\tprocid        uint64            // for debuggers, but offset not hard-coded\r\n\tgsignal       *g                // signal-handling g\r\n\tgoSigStack    gsignalStack      // Go-allocated signal handling stack\r\n\tsigmask       sigset            // storage for saved signal mask\r\n\ttls           [tlsSlots]uintptr // thread-local storage (for x86 extern register)\r\n\tmstartfn      func()\r\n\tcurg          *g       // current running goroutine\r\n\tcaughtsig     guintptr // goroutine running during fatal signal\r\n\tp             puintptr // attached p for executing go code (nil if not executing go code)\r\n\tnextp         puintptr\r\n\toldp          puintptr // the p that was attached before executing a syscall\r\n\tid            int64\r\n\tmallocing     int32\r\n\tthrowing      throwType\r\n\tpreemptoff    string // if != "", keep curg running on this m\r\n\tlocks         int32\r\n\tdying         int32\r\n\tprofilehz     int32\r\n\tspinning      bool // m is out of work and is actively looking for work\r\n\tblocked       bool // m is blocked on a note\r\n\tnewSigstack   bool // minit on C thread called sigaltstack\r\n\tprintlock     int8\r\n\tincgo         bool   // m is executing a cgo call\r\n\tfreeWait      uint32 // if == 0, safe to free g0 and delete m (atomic)\r\n\tfastrand      uint64\r\n\tneedextram    bool\r\n\ttraceback     uint8\r\n\tncgocall      uint64      // number of cgo calls in total\r\n\tncgo          int32       // number of cgo calls currently in progress\r\n\tcgoCallersUse uint32      // if non-zero, cgoCallers in use temporarily\r\n\tcgoCallers    *cgoCallers // cgo traceback if crashing in cgo call\r\n\tpark          note\r\n\talllink       *m // on allm\r\n\tschedlink     muintptr\r\n\tlockedg       guintptr\r\n\tcreatestack   [32]uintptr // stack that created this thread.\r\n\tlockedExt     uint32      // tracking for external LockOSThread\r\n\tlockedInt     uint32      // tracking for internal lockOSThread\r\n\tnextwaitm     muintptr    // next m waiting for lock\r\n\twaitunlockf   func(*g, unsafe.Pointer) bool\r\n\twaitlock      unsafe.Pointer\r\n\twaittraceev   byte\r\n\twaittraceskip int\r\n\tstartingtrace bool\r\n\tsyscalltick   uint32\r\n\tfreelink      *m // on sched.freem\r\n\r\n\t// these are here because they are too large to be on the stack\r\n\t// of low-level NOSPLIT functions.\r\n\tlibcall   libcall\r\n\tlibcallpc uintptr // for cpu profiler\r\n\tlibcallsp uintptr\r\n\tlibcallg  guintptr\r\n\tsyscall   libcall // stores syscall parameters on windows\r\n\r\n\tvdsoSP uintptr // SP for traceback while in VDSO call (0 if not in call)\r\n\tvdsoPC uintptr // PC for traceback while in VDSO call\r\n\r\n\t// preemptGen counts the number of completed preemption\r\n\t// signals. This is used to detect when a preemption is\r\n\t// requested, but fails. Accessed atomically.\r\n\tpreemptGen uint32\r\n\r\n\t// Whether this is a pending preemption signal on this M.\r\n\t// Accessed atomically.\r\n\tsignalPending uint32\r\n\r\n\tdlogPerM\r\n\r\n\tmOS\r\n\r\n\t// Up to 10 locks held by this m, maintained by the lock ranking code.\r\n\tlocksHeldLen int\r\n\tlocksHeld    [10]heldLockInfo\r\n}\n'})}),"\n",(0,r.jsx)(n.p,{children:"work-strealing"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-golang",children:"runtime.schedule() {\r\n    // only 1/61 of the time, check the global runnable queue for a G.\r\n    // if not found, check the local queue.\r\n    // if not found,\r\n    //     try to steal from other Ps.\r\n    //     if not, check the global runnable queue.\r\n    //     if not found, poll network.\r\n}\n"})}),"\n",(0,r.jsx)(n.h4,{id:"\u8c03\u5ea6\u7b56\u7565",children:"\u8c03\u5ea6\u7b56\u7565"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://github.com/lifei6671/interview-go/blob/master/base/go-scheduler.md",children:"https://github.com/lifei6671/interview-go/blob/master/base/go-scheduler.md"})})]})}function g(t={}){const{wrapper:n}={...(0,o.R)(),...t.components};return n?(0,r.jsx)(n,{...t,children:(0,r.jsx)(u,{...t})}):u(t)}},28453:(t,n,e)=>{e.d(n,{R:()=>a,x:()=>s});var r=e(96540);const o={},i=r.createContext(o);function a(t){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof t?t(n):{...n,...t}}),[n,t])}function s(t){let n;return n=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:a(t.components),r.createElement(i.Provider,{value:n},t.children)}}}]);