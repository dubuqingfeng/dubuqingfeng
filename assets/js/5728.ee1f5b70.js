/*! For license information please see 5728.ee1f5b70.js.LICENSE.txt */
(self.webpackChunkdubuqingfeng=self.webpackChunkdubuqingfeng||[]).push([[5728],{50291:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.Common=void 0;const n=r(68683),s=r(52566),i=r(37007),a=r(10406),c=r(12336),f=r(17280),d=r(13737),u=r(14429),h=r(44146),l=r(32538),p=r(69113),m=r(31161);class g extends i.EventEmitter{constructor(e){super(),this._eips=[],this._customChains=e.customChains??[],this._chainParams=this.setChain(e.chain),this.DEFAULT_HARDFORK=this._chainParams.defaultHardfork??l.Hardfork.Merge,this.HARDFORK_CHANGES=this.hardforks().map((e=>[e.name,p.hardforks[e.name]])),this._hardfork=this.DEFAULT_HARDFORK,void 0!==e.hardfork&&this.setHardfork(e.hardfork),e.eips&&this.setEIPs(e.eips)}static custom(e,t={}){const r=t.baseChain??"mainnet",o={...g._getChainParams(r)};if(o.name="custom-chain","string"!=typeof e)return new g({chain:{...o,...e},...t});if(e===l.CustomChain.PolygonMainnet)return g.custom({name:l.CustomChain.PolygonMainnet,chainId:137,networkId:137},t);if(e===l.CustomChain.PolygonMumbai)return g.custom({name:l.CustomChain.PolygonMumbai,chainId:80001,networkId:80001},t);if(e===l.CustomChain.ArbitrumRinkebyTestnet)return g.custom({name:l.CustomChain.ArbitrumRinkebyTestnet,chainId:421611,networkId:421611},t);if(e===l.CustomChain.ArbitrumOne)return g.custom({name:l.CustomChain.ArbitrumOne,chainId:42161,networkId:42161},t);if(e===l.CustomChain.xDaiChain)return g.custom({name:l.CustomChain.xDaiChain,chainId:100,networkId:100},t);if(e===l.CustomChain.OptimisticKovan)return g.custom({name:l.CustomChain.OptimisticKovan,chainId:69,networkId:69},{hardfork:l.Hardfork.Berlin,...t});if(e===l.CustomChain.OptimisticEthereum)return g.custom({name:l.CustomChain.OptimisticEthereum,chainId:10,networkId:10},{hardfork:l.Hardfork.Berlin,...t});throw new Error(`Custom chain ${e} not supported`)}static fromGethGenesis(e,{chain:t,eips:r,genesisHash:o,hardfork:n,mergeForkIdPostMerge:s}){const i=(0,m.parseGethGenesis)(e,t,s),a=new g({chain:i.name??"custom",customChains:[i],eips:r,hardfork:n??i.hardfork});return void 0!==o&&a.setForkHashes(o),a}static isSupportedChainId(e){const t=this._getInitializedChains();return Boolean(t.names[e.toString()])}static _getChainParams(e,t){const r=this._getInitializedChains(t);if("number"==typeof e||"bigint"==typeof e){if(e=e.toString(),r.names[e]){return r[r.names[e]]}throw new Error(`Chain with ID ${e} not supported`)}if(void 0!==r[e])return r[e];throw new Error(`Chain with name ${e} not supported`)}setChain(e){if("number"==typeof e||"bigint"==typeof e||"string"==typeof e)this._chainParams=g._getChainParams(e,this._customChains);else{if("object"!=typeof e)throw new Error("Wrong input format");{if(this._customChains.length>0)throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");const t=["networkId","genesis","hardforks","bootstrapNodes"];for(const r of t)if(!(r in e))throw new Error(`Missing required chain parameter: ${r}`);this._chainParams=e}}for(const t of this.hardforks())if(void 0===t.block)throw new Error("Hardfork cannot have undefined block number");return this._chainParams}setHardfork(e){let t=!1;for(const r of this.HARDFORK_CHANGES)r[0]===e&&(this._hardfork!==e&&(this._hardfork=e,this.emit("hardforkChanged",e)),t=!0);if(!t)throw new Error(`Hardfork with name ${e} not supported`)}getHardforkByBlockNumber(e,t,r){e=(0,n.toType)(e,n.TypeOutput.BigInt),t=(0,n.toType)(t,n.TypeOutput.BigInt),r=(0,n.toType)(r,n.TypeOutput.Number);const o=this.hardforks().filter((e=>null!==e.block||null!==e.ttd&&void 0!==e.ttd||void 0!==e.timestamp)),s=o.findIndex((e=>null!==e.ttd&&void 0!==e.ttd));if(o.slice(s+1).findIndex((e=>null!==e.ttd&&void 0!==e.ttd))>=0)throw Error("More than one merge hardforks found with ttd specified");let i=o.findIndex((t=>null!==t.block&&t.block>e||void 0!==r&&Number(t.timestamp)>r));if(-1===i)i=o.length;else if(0===i)throw Error("Must have at least one hardfork at block 0");if(void 0===r){i-=o.slice(0,i).reverse().findIndex((e=>null!==e.block||void 0!==e.ttd))}if(i-=1,null===o[i].block&&void 0===o[i].timestamp)(null==t||BigInt(o[i].ttd)>t)&&(i-=1);else if(s>=0&&null!=t){if(i>=s&&BigInt(o[s].ttd)>t)throw Error("Maximum HF determined by total difficulty is lower than the block number HF");if(i<s&&BigInt(o[s].ttd)<=t)throw Error("HF determined by block number is lower than the minimum total difficulty HF")}const a=i;for(;i<o.length-1&&(o[i].block===o[i+1].block&&o[i].timestamp===o[i+1].timestamp);i++);if(r){if(o.slice(0,a).reduce(((e,t)=>Math.max(Number(t.timestamp??"0"),e)),0)>r)throw Error("Maximum HF determined by timestamp is lower than the block number/ttd HF");if(o.slice(i+1).reduce(((e,t)=>Math.min(Number(t.timestamp??r),e)),r)<r)throw Error("Maximum HF determined by block number/ttd is lower than timestamp HF")}return o[i].name}setHardforkByBlockNumber(e,t,r){const o=this.getHardforkByBlockNumber(e,t,r);return this.setHardfork(o),o}_getHardfork(e){const t=this.hardforks();for(const r of t)if(r.name===e)return r;return null}setEIPs(e=[]){for(const t of e){if(!(t in h.EIPs))throw new Error(`${t} not supported`);const r=this.gteHardfork(h.EIPs[t].minimumHardfork);if(!r)throw new Error(`${t} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${r}`);if(void 0!==h.EIPs[t].requiredEIPs)for(const o of h.EIPs[t].requiredEIPs)if(!e.includes(o)&&!this.isActivatedEIP(o))throw new Error(`${t} requires EIP ${o}, but is not included in the EIP list`)}this._eips=e}param(e,t){let r;for(const o of this._eips)if(r=this.paramByEIP(e,t,o),void 0!==r)return r;return this.paramByHardfork(e,t,this._hardfork)}paramByHardfork(e,t,r){let o=null;for(const n of this.HARDFORK_CHANGES){if("eips"in n[1]){const r=n[1].eips;for(const n of r){const r=this.paramByEIP(e,t,n);o="bigint"==typeof r?r:o}}else{if(void 0===n[1][e])throw new Error(`Topic ${e} not defined`);void 0!==n[1][e][t]&&(o=n[1][e][t].v)}if(n[0]===r)break}return BigInt(o??0)}paramByEIP(e,t,r){if(!(r in h.EIPs))throw new Error(`${r} not supported`);const o=h.EIPs[r];if(!(e in o))throw new Error(`Topic ${e} not defined`);if(void 0===o[e][t])return;const n=o[e][t].v;return BigInt(n)}paramByBlock(e,t,r,o,n){const s=this.getHardforkByBlockNumber(r,o,n);return this.paramByHardfork(e,t,s)}isActivatedEIP(e){if(this.eips().includes(e))return!0;for(const t of this.HARDFORK_CHANGES){const r=t[1];if(this.gteHardfork(r.name)&&"eips"in r&&r.eips.includes(e))return!0}return!1}hardforkIsActiveOnBlock(e,t){t=(0,n.toType)(t,n.TypeOutput.BigInt),e=e??this._hardfork;const r=this.hardforkBlock(e);return"bigint"==typeof r&&r!==BigInt(0)&&t>=r}activeOnBlock(e){return this.hardforkIsActiveOnBlock(null,e)}hardforkGteHardfork(e,t){e=e??this._hardfork;const r=this.hardforks();let o=-1,n=-1,s=0;for(const i of r)i.name===e&&(o=s),i.name===t&&(n=s),s+=1;return o>=n&&-1!==n}gteHardfork(e){return this.hardforkGteHardfork(null,e)}hardforkBlock(e){e=e??this._hardfork;const t=this._getHardfork(e)?.block;return null==t?null:BigInt(t)}hardforkTimestamp(e){e=e??this._hardfork;const t=this._getHardfork(e)?.timestamp;return null==t?null:BigInt(t)}eipBlock(e){for(const t of this.HARDFORK_CHANGES){const r=t[1];if("eips"in r&&r.eips.includes(e))return this.hardforkBlock(t[0])}return null}hardforkTTD(e){e=e??this._hardfork;const t=this._getHardfork(e)?.ttd;return null==t?null:BigInt(t)}isHardforkBlock(e,t){e=(0,n.toType)(e,n.TypeOutput.BigInt),t=t??this._hardfork;const r=this.hardforkBlock(t);return"bigint"==typeof r&&r!==BigInt(0)&&r===e}nextHardforkBlockOrTimestamp(e){e=e??this._hardfork;const t=this.hardforks();let r=t.findIndex((t=>t.name===e));if(e===l.Hardfork.Merge&&(r-=1),r<0)return null;let o=t[r].timestamp??t[r].block;o=null!=o?Number(o):null;const n=t.slice(r+1).find((e=>{let t=e.timestamp??e.block;return t=null!=t?Number(t):null,e.name!==l.Hardfork.Merge&&null!=t&&t!==o}));if(void 0===n)return null;const s=n.timestamp??n.block;return null==s?null:BigInt(s)}nextHardforkBlock(e){e=e??this._hardfork;let t=this.hardforkBlock(e);if(null===t&&e===l.Hardfork.Merge){const e=this.hardforks(),r=e.findIndex((e=>null!==e.ttd&&void 0!==e.ttd));if(r<0)throw Error("Merge hardfork should have been found");t=this.hardforkBlock(e[r-1].name)}if(null===t)return null;return this.hardforks().reduce(((e,r)=>{const o=BigInt(null===r.block||void 0!==r.ttd&&null!==r.ttd?0:r.block);return o>t&&null===e?o:e}),null)}isNextHardforkBlock(e,t){e=(0,n.toType)(e,n.TypeOutput.BigInt),t=t??this._hardfork;const r=this.nextHardforkBlock(t);return null!==r&&r===e}_calcForkHash(e,t){let r=o.alloc(0),i=0;for(const n of this.hardforks()){const{block:t,timestamp:s,name:a}=n;let c=s??t;if(c=null!==c?Number(c):null,"number"==typeof c&&0!==c&&c!==i&&a!==l.Hardfork.Merge){const e=o.from(c.toString(16).padStart(16,"0"),"hex");r=o.concat([r,e]),i=c}if(n.name===e)break}const a=o.concat([t,r]);return`0x${(0,n.intToBuffer)((0,s.buf)(a)>>>0).toString("hex")}`}forkHash(e,t){e=e??this._hardfork;const r=this._getHardfork(e);if(null===r||null===r?.block&&void 0===r?.timestamp&&void 0===r?.ttd){throw new Error("No fork hash calculation possible for future hardfork")}if(null!=r?.forkHash)return r.forkHash;if(!t)throw new Error("genesisHash required for forkHash calculation");return this._calcForkHash(e,t)}hardforkForForkHash(e){const t=this.hardforks().filter((t=>t.forkHash===e));return t.length>=1?t[t.length-1]:null}setForkHashes(e){for(const t of this.hardforks()){const r=t.timestamp??t.block;null!==t.forkHash&&void 0!==t.forkHash||null==r&&void 0===t.ttd||(t.forkHash=this.forkHash(t.name,e))}}genesis(){return this._chainParams.genesis}hardforks(){return this._chainParams.hardforks}bootstrapNodes(){return this._chainParams.bootstrapNodes}dnsNetworks(){return this._chainParams.dnsNetworks}hardfork(){return this._hardfork}chainId(){return BigInt(this._chainParams.chainId)}chainName(){return this._chainParams.name}networkId(){return BigInt(this._chainParams.networkId)}eips(){return this._eips}consensusType(){const e=this.hardfork();let t;for(const r of this.HARDFORK_CHANGES)if("consensus"in r[1]&&(t=r[1].consensus.type),r[0]===e)break;return t??this._chainParams.consensus.type}consensusAlgorithm(){const e=this.hardfork();let t;for(const r of this.HARDFORK_CHANGES)if("consensus"in r[1]&&(t=r[1].consensus.algorithm),r[0]===e)break;return t??this._chainParams.consensus.algorithm}consensusConfig(){const e=this.hardfork();let t;for(const r of this.HARDFORK_CHANGES)if("consensus"in r[1]&&(t=r[1].consensus[r[1].consensus.algorithm]),r[0]===e)break;return t??this._chainParams.consensus[this.consensusAlgorithm()]??{}}copy(){const e=Object.assign(Object.create(Object.getPrototypeOf(this)),this);return e.removeAllListeners(),e}static _getInitializedChains(e){const t={};for(const[o,n]of Object.entries(l.Chain))t[n]=o.toLowerCase();const r={mainnet:c,ropsten:d,rinkeby:f,goerli:a,sepolia:u};if(e)for(const o of e){const{name:e}=o;t[o.chainId.toString()]=e,r[e]=o}return r.names=t,r}}t.Common=g},44146:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.EIPs=void 0,t.EIPs={1153:r(42973),1559:r(23031),2315:r(14918),2537:r(86284),2565:r(78315),2718:r(61417),2929:r(76967),2930:r(67577),3074:r(46475),3198:r(48542),3529:r(77294),3540:r(331),3541:r(91464),3554:r(44298),3607:r(45515),3651:r(77436),3670:r(75569),3675:r(31770),3855:r(57610),3860:r(58842),4345:r(86865),4399:r(75160),4844:r(76111),4895:r(63025),5133:r(62047)}},32538:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CustomChain=t.ConsensusAlgorithm=t.ConsensusType=t.Hardfork=t.Chain=void 0,function(e){e[e.Mainnet=1]="Mainnet",e[e.Ropsten=3]="Ropsten",e[e.Rinkeby=4]="Rinkeby",e[e.Goerli=5]="Goerli",e[e.Sepolia=11155111]="Sepolia"}(t.Chain||(t.Chain={})),function(e){e.Chainstart="chainstart",e.Homestead="homestead",e.Dao="dao",e.TangerineWhistle="tangerineWhistle",e.SpuriousDragon="spuriousDragon",e.Byzantium="byzantium",e.Constantinople="constantinople",e.Petersburg="petersburg",e.Istanbul="istanbul",e.MuirGlacier="muirGlacier",e.Berlin="berlin",e.London="london",e.ArrowGlacier="arrowGlacier",e.GrayGlacier="grayGlacier",e.MergeForkIdTransition="mergeForkIdTransition",e.Merge="merge",e.Shanghai="shanghai",e.ShardingForkDev="shardingFork"}(t.Hardfork||(t.Hardfork={})),function(e){e.ProofOfStake="pos",e.ProofOfWork="pow",e.ProofOfAuthority="poa"}(t.ConsensusType||(t.ConsensusType={})),function(e){e.Ethash="ethash",e.Clique="clique",e.Casper="casper"}(t.ConsensusAlgorithm||(t.ConsensusAlgorithm={})),function(e){e.PolygonMainnet="polygon-mainnet",e.PolygonMumbai="polygon-mumbai",e.ArbitrumRinkebyTestnet="arbitrum-rinkeby-testnet",e.ArbitrumOne="arbitrum-one",e.xDaiChain="x-dai-chain",e.OptimisticKovan="optimistic-kovan",e.OptimisticEthereum="optimistic-ethereum"}(t.CustomChain||(t.CustomChain={}))},69113:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.hardforks=void 0,t.hardforks={chainstart:r(61497),homestead:r(9448),dao:r(27582),tangerineWhistle:r(53725),spuriousDragon:r(53521),byzantium:r(13821),constantinople:r(88593),petersburg:r(11683),istanbul:r(77e3),muirGlacier:r(99752),berlin:r(72094),london:r(68816),shanghai:r(62783),arrowGlacier:r(94164),grayGlacier:r(62386),mergeForkIdTransition:r(69828),merge:r(69430),shardingFork:r(49302)}},18144:function(e,t,r){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||o(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),n(r(50291),t),n(r(32538),t),n(r(3909),t),n(r(31161),t)},3909:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0})},31161:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.parseGethGenesis=void 0;const o=r(68683),n=r(32538);function s(e,t=!0){const{name:r,config:s,difficulty:i,mixHash:a,gasLimit:c,coinbase:f,baseFeePerGas:d}=e;let{extraData:u,timestamp:h,nonce:l}=e;const p=Number(h),{chainId:m}=s;if(""===u&&(u="0x"),(0,o.isHexPrefixed)(h)||(h=(0,o.intToHex)(parseInt(h))),18!==l.length&&(l=function(e){return e&&"0x0"!==e?(0,o.isHexPrefixed)(e)?"0x"+(0,o.stripHexPrefix)(e).padStart(16,"0"):"0x"+e.padStart(16,"0"):"0x0000000000000000"}(l)),s.eip155Block!==s.eip158Block)throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");const g={name:r,chainId:m,networkId:m,genesis:{timestamp:h,gasLimit:parseInt(c),difficulty:parseInt(i),nonce:l,extraData:u,mixHash:a,coinbase:f,baseFeePerGas:d},hardfork:void 0,hardforks:[],bootstrapNodes:[],consensus:void 0!==s.clique?{type:"poa",algorithm:"clique",clique:{period:s.clique.period??s.clique.blockperiodseconds,epoch:s.clique.epoch??s.clique.epochlength}}:{type:"pow",algorithm:"ethash",ethash:{}}},b={[n.Hardfork.Homestead]:{name:"homesteadBlock"},[n.Hardfork.Dao]:{name:"daoForkBlock"},[n.Hardfork.TangerineWhistle]:{name:"eip150Block"},[n.Hardfork.SpuriousDragon]:{name:"eip155Block"},[n.Hardfork.Byzantium]:{name:"byzantiumBlock"},[n.Hardfork.Constantinople]:{name:"constantinopleBlock"},[n.Hardfork.Petersburg]:{name:"petersburgBlock"},[n.Hardfork.Istanbul]:{name:"istanbulBlock"},[n.Hardfork.MuirGlacier]:{name:"muirGlacierBlock"},[n.Hardfork.Berlin]:{name:"berlinBlock"},[n.Hardfork.London]:{name:"londonBlock"},[n.Hardfork.MergeForkIdTransition]:{name:"mergeForkBlock",postMerge:t},[n.Hardfork.Shanghai]:{name:"shanghaiTime",postMerge:!0,isTimestamp:!0},[n.Hardfork.ShardingForkDev]:{name:"shardingForkTime",postMerge:!0,isTimestamp:!0}},y=Object.keys(b).reduce(((e,t)=>(e[b[t].name]=t,e)),{}),v=Object.keys(s).filter((e=>void 0!==y[e]&&void 0!==s[e]&&null!==s[e]));if(g.hardforks=v.map((e=>({name:y[e],block:!0===b[y[e]].isTimestamp||"number"!=typeof s[e]?null:s[e],timestamp:!0===b[y[e]].isTimestamp&&"number"==typeof s[e]?s[e]:void 0}))).filter((e=>null!==e.block||void 0!==e.timestamp)),g.hardforks.sort((function(e,t){return(e.block??1/0)-(t.block??1/0)})),g.hardforks.sort((function(e,t){return(e.timestamp??p)-(t.timestamp??p)})),void 0!==s.terminalTotalDifficulty){const e={name:n.Hardfork.Merge,ttd:s.terminalTotalDifficulty,block:null},t=g.hardforks.findIndex((e=>!0===b[e.name]?.postMerge));-1!==t?g.hardforks.splice(t,0,e):g.hardforks.push(e)}const w=g.hardforks.length>0?g.hardforks.slice(-1)[0]:void 0;return g.hardfork=w?.name,g.hardforks.unshift({name:n.Hardfork.Chainstart,block:0}),g}t.parseGethGenesis=function(e,t,r){try{if(["config","difficulty","gasLimit","alloc"].some((t=>!(t in e))))throw new Error("Invalid format, expected geth genesis fields missing");return void 0!==t&&(e.name=t),s(e,r)}catch(o){throw new Error(`Error parsing parameters file: ${o.message}`)}}},16256:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.BaseTransaction=void 0;const o=r(18144),n=r(68683),s=r(62418),i=r(58843);t.BaseTransaction=class{constructor(e,t){this.cache={hash:void 0,dataFee:void 0},this.activeCapabilities=[],this.DEFAULT_CHAIN=o.Chain.Mainnet,this.DEFAULT_HARDFORK=o.Hardfork.Merge;const{nonce:r,gasLimit:s,to:a,value:c,data:f,v:d,r:u,s:h,type:l}=e;this._type=Number((0,n.bufferToBigInt)((0,n.toBuffer)(l))),this.txOptions=t;const p=(0,n.toBuffer)(""===a?"0x":a),m=(0,n.toBuffer)(""===d?"0x":d),g=(0,n.toBuffer)(""===u?"0x":u),b=(0,n.toBuffer)(""===h?"0x":h);this.nonce=(0,n.bufferToBigInt)((0,n.toBuffer)(""===r?"0x":r)),this.gasLimit=(0,n.bufferToBigInt)((0,n.toBuffer)(""===s?"0x":s)),this.to=p.length>0?new n.Address(p):void 0,this.value=(0,n.bufferToBigInt)((0,n.toBuffer)(""===c?"0x":c)),this.data=(0,n.toBuffer)(""===f?"0x":f),this.v=m.length>0?(0,n.bufferToBigInt)(m):void 0,this.r=g.length>0?(0,n.bufferToBigInt)(g):void 0,this.s=b.length>0?(0,n.bufferToBigInt)(b):void 0,this._validateCannotExceedMaxInteger({value:this.value,r:this.r,s:this.s}),this._validateCannotExceedMaxInteger({gasLimit:this.gasLimit},64),this._validateCannotExceedMaxInteger({nonce:this.nonce},64,!0);const y=void 0===this.to||null===this.to,v=t.allowUnlimitedInitCodeSize??!1,w=t.common??this._getCommon();y&&w.isActivatedEIP(3860)&&!1===v&&(0,i.checkMaxInitCodeSize)(w,this.data.length)}get type(){return this._type}supports(e){return this.activeCapabilities.includes(e)}validate(e=!1){const t=[];return this.getBaseFee()>this.gasLimit&&t.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`),this.isSigned()&&!this.verifySignature()&&t.push("Invalid Signature"),e?t:0===t.length}_validateYParity(){const{v:e}=this;if(void 0!==e&&e!==BigInt(0)&&e!==BigInt(1)){const e=this._errorMsg("The y-parity of the transaction should either be 0 or 1");throw new Error(e)}}_validateHighS(){const{s:e}=this;if(this.common.gteHardfork("homestead")&&void 0!==e&&e>n.SECP256K1_ORDER_DIV_2){const e=this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");throw new Error(e)}}getBaseFee(){const e=this.common.param("gasPrices","tx");let t=this.getDataFee();if(e&&(t+=e),this.common.gteHardfork("homestead")&&this.toCreationAddress()){const e=this.common.param("gasPrices","txCreation");e&&(t+=e)}return t}getDataFee(){const e=this.common.param("gasPrices","txDataZero"),t=this.common.param("gasPrices","txDataNonZero");let r=BigInt(0);for(let o=0;o<this.data.length;o++)0===this.data[o]?r+=e:r+=t;if((void 0===this.to||null===this.to)&&this.common.isActivatedEIP(3860)){const e=BigInt(Math.ceil(this.data.length/32));r+=this.common.param("gasPrices","initCodeWordCost")*e}return r}toCreationAddress(){return void 0===this.to||0===this.to.buf.length}isSigned(){const{v:e,r:t,s:r}=this;return void 0!==e&&void 0!==t&&void 0!==r}verifySignature(){try{const e=this.getSenderPublicKey();return 0!==(0,n.unpadBuffer)(e).length}catch(e){return!1}}getSenderAddress(){return new n.Address((0,n.publicToAddress)(this.getSenderPublicKey()))}sign(e){if(32!==e.length){const e=this._errorMsg("Private key must be 32 bytes in length.");throw new Error(e)}let t=!1;0===this.type&&this.common.gteHardfork("spuriousDragon")&&!this.supports(s.Capability.EIP155ReplayProtection)&&(this.activeCapabilities.push(s.Capability.EIP155ReplayProtection),t=!0);const r=this.getMessageToSign(!0),{v:o,r:i,s:a}=(0,n.ecsign)(r,e),c=this._processSignature(o,i,a);if(t){const e=this.activeCapabilities.indexOf(s.Capability.EIP155ReplayProtection);e>-1&&this.activeCapabilities.splice(e,1)}return c}_getCommon(e,t){if(void 0!==t){const r=(0,n.bufferToBigInt)((0,n.toBuffer)(t));if(e){if(e.chainId()!==r){const e=this._errorMsg("The chain ID does not match the chain ID of Common");throw new Error(e)}return e.copy()}return o.Common.isSupportedChainId(r)?new o.Common({chain:r,hardfork:this.DEFAULT_HARDFORK}):o.Common.custom({name:"custom-chain",networkId:r,chainId:r},{baseChain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}return e?.copy()??new o.Common({chain:this.DEFAULT_CHAIN,hardfork:this.DEFAULT_HARDFORK})}_validateCannotExceedMaxInteger(e,t=256,r=!1){for(const[o,s]of Object.entries(e))switch(t){case 64:if(r){if(void 0!==s&&s>=n.MAX_UINT64){const e=this._errorMsg(`${o} cannot equal or exceed MAX_UINT64 (2^64-1), given ${s}`);throw new Error(e)}}else if(void 0!==s&&s>n.MAX_UINT64){const e=this._errorMsg(`${o} cannot exceed MAX_UINT64 (2^64-1), given ${s}`);throw new Error(e)}break;case 256:if(r){if(void 0!==s&&s>=n.MAX_INTEGER){const e=this._errorMsg(`${o} cannot equal or exceed MAX_INTEGER (2^256-1), given ${s}`);throw new Error(e)}}else if(void 0!==s&&s>n.MAX_INTEGER){const e=this._errorMsg(`${o} cannot exceed MAX_INTEGER (2^256-1), given ${s}`);throw new Error(e)}break;default:{const e=this._errorMsg("unimplemented bits value");throw new Error(e)}}}static _validateNotArray(e){const t=["nonce","gasPrice","gasLimit","to","value","data","v","r","s","type","baseFee","maxFeePerGas","chainId"];for(const[r,o]of Object.entries(e))if(t.includes(r)&&Array.isArray(o))throw new Error(`${r} cannot be an array`)}_getSharedErrorPostfix(){let e="";try{e=this.isSigned()?(0,n.bufferToHex)(this.hash()):"not available (unsigned)"}catch(s){e="error"}let t="";try{t=this.isSigned().toString()}catch(s){e="error"}let r="";try{r=this.common.hardfork()}catch(s){r="error"}let o=`tx type=${this.type} hash=${e} nonce=${this.nonce} value=${this.value} `;return o+=`signed=${t} hf=${r}`,o}}},26889:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.FeeMarketEIP1559Transaction=void 0;const n=r(66289),s=r(68683),i=r(32019),a=r(16256),c=r(58843),f=o.from(2..toString(16).padStart(2,"0"),"hex");class d extends a.BaseTransaction{constructor(e,t={}){super({...e,type:2},t),this.DEFAULT_HARDFORK="london";const{chainId:r,accessList:o,maxFeePerGas:n,maxPriorityFeePerGas:i}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),!1===this.common.isActivatedEIP(1559))throw new Error("EIP-1559 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([1559,2718,2930]);const f=c.AccessLists.getAccessListData(o??[]);if(this.accessList=f.accessList,this.AccessListJSON=f.AccessListJSON,c.AccessLists.verifyAccessList(this.accessList),this.maxFeePerGas=(0,s.bufferToBigInt)((0,s.toBuffer)(""===n?"0x":n)),this.maxPriorityFeePerGas=(0,s.bufferToBigInt)((0,s.toBuffer)(""===i?"0x":i)),this._validateCannotExceedMaxInteger({maxFeePerGas:this.maxFeePerGas,maxPriorityFeePerGas:this.maxPriorityFeePerGas}),a.BaseTransaction._validateNotArray(e),this.gasLimit*this.maxFeePerGas>s.MAX_INTEGER){const e=this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");throw new Error(e)}if(this.maxFeePerGas<this.maxPriorityFeePerGas){const e=this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");throw new Error(e)}this._validateYParity(),this._validateHighS();(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new d(e,t)}static fromSerializedTx(e,t={}){if(!e.slice(0,1).equals(f))throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: 2, received: ${e.slice(0,1).toString("hex")}`);const r=(0,s.arrToBufArr)(n.RLP.decode(e.slice(1)));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return d.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(9!==e.length&&12!==e.length)throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");const[r,o,n,i,a,c,f,u,h,l,p,m]=e;return this._validateNotArray({chainId:r,v:l}),(0,s.validateNoLeadingZeroes)({nonce:o,maxPriorityFeePerGas:n,maxFeePerGas:i,gasLimit:a,value:f,v:l,r:p,s:m}),new d({chainId:(0,s.bufferToBigInt)(r),nonce:o,maxPriorityFeePerGas:n,maxFeePerGas:i,gasLimit:a,to:c,value:f,data:u,accessList:h??[],v:void 0!==l?(0,s.bufferToBigInt)(l):void 0,r:p,s:m},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(c.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(e=BigInt(0)){const t=this.maxPriorityFeePerGas,r=this.maxFeePerGas-e,o=(t<r?t:r)+e;return this.gasLimit*o+this.value}raw(){return[(0,s.bigIntToUnpaddedBuffer)(this.chainId),(0,s.bigIntToUnpaddedBuffer)(this.nonce),(0,s.bigIntToUnpaddedBuffer)(this.maxPriorityFeePerGas),(0,s.bigIntToUnpaddedBuffer)(this.maxFeePerGas),(0,s.bigIntToUnpaddedBuffer)(this.gasLimit),void 0!==this.to?this.to.buf:o.from([]),(0,s.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,void 0!==this.v?(0,s.bigIntToUnpaddedBuffer)(this.v):o.from([]),void 0!==this.r?(0,s.bigIntToUnpaddedBuffer)(this.r):o.from([]),void 0!==this.s?(0,s.bigIntToUnpaddedBuffer)(this.s):o.from([])]}serialize(){const e=this.raw();return o.concat([f,o.from(n.RLP.encode((0,s.bufArrToArr)(e)))])}getMessageToSign(e=!0){const t=this.raw().slice(0,9),r=o.concat([f,o.from(n.RLP.encode((0,s.bufArrToArr)(t)))]);return e?o.from((0,i.keccak256)(r)):r}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=o.from((0,i.keccak256)(this.serialize()))),this.cache.hash):o.from((0,i.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const e=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(e)}const e=this.getMessageToVerifySignature(),{v:t,r:r,s:o}=this;this._validateHighS();try{return(0,s.ecrecover)(e,t+BigInt(27),(0,s.bigIntToUnpaddedBuffer)(r),(0,s.bigIntToUnpaddedBuffer)(o))}catch(n){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,r){const o={...this.txOptions,common:this.common};return d.fromTxData({chainId:this.chainId,nonce:this.nonce,maxPriorityFeePerGas:this.maxPriorityFeePerGas,maxFeePerGas:this.maxFeePerGas,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,s.bufferToBigInt)(t),s:(0,s.bufferToBigInt)(r)},o)}toJSON(){const e=c.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,s.bigIntToHex)(this.chainId),nonce:(0,s.bigIntToHex)(this.nonce),maxPriorityFeePerGas:(0,s.bigIntToHex)(this.maxPriorityFeePerGas),maxFeePerGas:(0,s.bigIntToHex)(this.maxFeePerGas),gasLimit:(0,s.bigIntToHex)(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:(0,s.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:void 0!==this.v?(0,s.bigIntToHex)(this.v):void 0,r:void 0!==this.r?(0,s.bigIntToHex)(this.r):void 0,s:void 0!==this.s?(0,s.bigIntToHex)(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}t.FeeMarketEIP1559Transaction=d},91675:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.AccessListEIP2930Transaction=void 0;const n=r(66289),s=r(68683),i=r(32019),a=r(16256),c=r(58843),f=o.from(1..toString(16).padStart(2,"0"),"hex");class d extends a.BaseTransaction{constructor(e,t={}){super({...e,type:1},t),this.DEFAULT_HARDFORK="berlin";const{chainId:r,accessList:o,gasPrice:n}=e;if(this.common=this._getCommon(t.common,r),this.chainId=this.common.chainId(),!this.common.isActivatedEIP(2930))throw new Error("EIP-2930 not enabled on Common");this.activeCapabilities=this.activeCapabilities.concat([2718,2930]);const i=c.AccessLists.getAccessListData(o??[]);if(this.accessList=i.accessList,this.AccessListJSON=i.AccessListJSON,c.AccessLists.verifyAccessList(this.accessList),this.gasPrice=(0,s.bufferToBigInt)((0,s.toBuffer)(""===n?"0x":n)),this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),a.BaseTransaction._validateNotArray(e),this.gasPrice*this.gasLimit>s.MAX_INTEGER){const e=this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");throw new Error(e)}this._validateYParity(),this._validateHighS();(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new d(e,t)}static fromSerializedTx(e,t={}){if(!e.slice(0,1).equals(f))throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: 1, received: ${e.slice(0,1).toString("hex")}`);const r=(0,s.arrToBufArr)(n.RLP.decode(Uint8Array.from(e.slice(1))));if(!Array.isArray(r))throw new Error("Invalid serialized tx input: must be array");return d.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(8!==e.length&&11!==e.length)throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");const[r,o,n,i,a,c,f,u,h,l,p]=e;this._validateNotArray({chainId:r,v:h}),(0,s.validateNoLeadingZeroes)({nonce:o,gasPrice:n,gasLimit:i,value:c,v:h,r:l,s:p});return new d({chainId:(0,s.bufferToBigInt)(r),nonce:o,gasPrice:n,gasLimit:i,to:a,value:c,data:f,accessList:u??[],v:void 0!==h?(0,s.bufferToBigInt)(h):void 0,r:l,s:p},t)}getDataFee(){if(this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork())return this.cache.dataFee.value;let e=super.getDataFee();return e+=BigInt(c.AccessLists.getDataFeeEIP2930(this.accessList,this.common)),Object.isFrozen(this)&&(this.cache.dataFee={value:e,hardfork:this.common.hardfork()}),e}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}raw(){return[(0,s.bigIntToUnpaddedBuffer)(this.chainId),(0,s.bigIntToUnpaddedBuffer)(this.nonce),(0,s.bigIntToUnpaddedBuffer)(this.gasPrice),(0,s.bigIntToUnpaddedBuffer)(this.gasLimit),void 0!==this.to?this.to.buf:o.from([]),(0,s.bigIntToUnpaddedBuffer)(this.value),this.data,this.accessList,void 0!==this.v?(0,s.bigIntToUnpaddedBuffer)(this.v):o.from([]),void 0!==this.r?(0,s.bigIntToUnpaddedBuffer)(this.r):o.from([]),void 0!==this.s?(0,s.bigIntToUnpaddedBuffer)(this.s):o.from([])]}serialize(){const e=this.raw();return o.concat([f,o.from(n.RLP.encode((0,s.bufArrToArr)(e)))])}getMessageToSign(e=!0){const t=this.raw().slice(0,8),r=o.concat([f,o.from(n.RLP.encode((0,s.bufArrToArr)(t)))]);return e?o.from((0,i.keccak256)(r)):r}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=o.from((0,i.keccak256)(this.serialize()))),this.cache.hash):o.from((0,i.keccak256)(this.serialize()))}getMessageToVerifySignature(){return this.getMessageToSign()}getSenderPublicKey(){if(!this.isSigned()){const e=this._errorMsg("Cannot call this method if transaction is not signed");throw new Error(e)}const e=this.getMessageToVerifySignature(),{v:t,r:r,s:o}=this;this._validateHighS();try{return(0,s.ecrecover)(e,t+BigInt(27),(0,s.bigIntToUnpaddedBuffer)(r),(0,s.bigIntToUnpaddedBuffer)(o))}catch(n){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,r){const o={...this.txOptions,common:this.common};return d.fromTxData({chainId:this.chainId,nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,accessList:this.accessList,v:e-BigInt(27),r:(0,s.bufferToBigInt)(t),s:(0,s.bufferToBigInt)(r)},o)}toJSON(){const e=c.AccessLists.getAccessListJSON(this.accessList);return{chainId:(0,s.bigIntToHex)(this.chainId),nonce:(0,s.bigIntToHex)(this.nonce),gasPrice:(0,s.bigIntToHex)(this.gasPrice),gasLimit:(0,s.bigIntToHex)(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:(0,s.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),accessList:e,v:void 0!==this.v?(0,s.bigIntToHex)(this.v):void 0,r:void 0!==this.r?(0,s.bigIntToHex)(this.r):void 0,s:void 0!==this.s?(0,s.bigIntToHex)(this.s):void 0}}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice} accessListCount=${this.accessList?.length??0}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}t.AccessListEIP2930Transaction=d},77976:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.normalizeTxParams=void 0;const o=r(68683);t.normalizeTxParams=e=>{const t=Object.assign({},e);return t.gasLimit=(0,o.toType)(t.gasLimit??t.gas,o.TypeOutput.BigInt),t.data=void 0===t.data?t.input:t.data,t.gasPrice=void 0!==t.gasPrice?BigInt(t.gasPrice):void 0,t.value=void 0!==t.value?BigInt(t.value):void 0,t.to=null!==t.to&&void 0!==t.to?(0,o.setLengthLeft)((0,o.toBuffer)(t.to),20):null,t.v="0x0"===t.v?"0x":t.v,t.r="0x0"===t.r?"0x":t.r,t.s="0x0"===t.s?"0x":t.s,"0x"!==t.v&&(t.v=(0,o.toType)(t.v,o.TypeOutput.BigInt)),t}},63347:function(e,t,r){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||o(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.TransactionFactory=t.Transaction=t.AccessListEIP2930Transaction=t.FeeMarketEIP1559Transaction=void 0;var s=r(26889);Object.defineProperty(t,"FeeMarketEIP1559Transaction",{enumerable:!0,get:function(){return s.FeeMarketEIP1559Transaction}});var i=r(91675);Object.defineProperty(t,"AccessListEIP2930Transaction",{enumerable:!0,get:function(){return i.AccessListEIP2930Transaction}});var a=r(19426);Object.defineProperty(t,"Transaction",{enumerable:!0,get:function(){return a.Transaction}});var c=r(68065);Object.defineProperty(t,"TransactionFactory",{enumerable:!0,get:function(){return c.TransactionFactory}}),n(r(62418),t)},19426:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.Transaction=void 0;const n=r(66289),s=r(68683),i=r(32019),a=r(16256),c=r(62418);function f(e,t){const r=Number(e),o=2*Number(t);return r===o+35||r===o+36}class d extends a.BaseTransaction{constructor(e,t={}){if(super({...e,type:0},t),this.common=this._validateTxV(this.v,t.common),this.gasPrice=(0,s.bufferToBigInt)((0,s.toBuffer)(""===e.gasPrice?"0x":e.gasPrice)),this.gasPrice*this.gasLimit>s.MAX_INTEGER){const e=this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");throw new Error(e)}this._validateCannotExceedMaxInteger({gasPrice:this.gasPrice}),a.BaseTransaction._validateNotArray(e),this.common.gteHardfork("spuriousDragon")&&(this.isSigned()?f(this.v,this.common.chainId())&&this.activeCapabilities.push(c.Capability.EIP155ReplayProtection):this.activeCapabilities.push(c.Capability.EIP155ReplayProtection));(t?.freeze??!0)&&Object.freeze(this)}static fromTxData(e,t={}){return new d(e,t)}static fromSerializedTx(e,t={}){const r=(0,s.arrToBufArr)(n.RLP.decode(Uint8Array.from(e)));if(!Array.isArray(r))throw new Error("Invalid serialized tx input. Must be array");return this.fromValuesArray(r,t)}static fromValuesArray(e,t={}){if(6!==e.length&&9!==e.length)throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");const[r,o,n,i,a,c,f,u,h]=e;return(0,s.validateNoLeadingZeroes)({nonce:r,gasPrice:o,gasLimit:n,value:a,v:f,r:u,s:h}),new d({nonce:r,gasPrice:o,gasLimit:n,to:i,value:a,data:c,v:f,r:u,s:h},t)}raw(){return[(0,s.bigIntToUnpaddedBuffer)(this.nonce),(0,s.bigIntToUnpaddedBuffer)(this.gasPrice),(0,s.bigIntToUnpaddedBuffer)(this.gasLimit),void 0!==this.to?this.to.buf:o.from([]),(0,s.bigIntToUnpaddedBuffer)(this.value),this.data,void 0!==this.v?(0,s.bigIntToUnpaddedBuffer)(this.v):o.from([]),void 0!==this.r?(0,s.bigIntToUnpaddedBuffer)(this.r):o.from([]),void 0!==this.s?(0,s.bigIntToUnpaddedBuffer)(this.s):o.from([])]}serialize(){return o.from(n.RLP.encode((0,s.bufArrToArr)(this.raw())))}_getMessageToSign(){const e=[(0,s.bigIntToUnpaddedBuffer)(this.nonce),(0,s.bigIntToUnpaddedBuffer)(this.gasPrice),(0,s.bigIntToUnpaddedBuffer)(this.gasLimit),void 0!==this.to?this.to.buf:o.from([]),(0,s.bigIntToUnpaddedBuffer)(this.value),this.data];return this.supports(c.Capability.EIP155ReplayProtection)&&(e.push((0,s.bigIntToUnpaddedBuffer)(this.common.chainId())),e.push((0,s.unpadBuffer)((0,s.toBuffer)(0))),e.push((0,s.unpadBuffer)((0,s.toBuffer)(0)))),e}getMessageToSign(e=!0){const t=this._getMessageToSign();return e?o.from((0,i.keccak256)(n.RLP.encode((0,s.bufArrToArr)(t)))):t}getDataFee(){return this.cache.dataFee&&this.cache.dataFee.hardfork===this.common.hardfork()?this.cache.dataFee.value:(Object.isFrozen(this)&&(this.cache.dataFee={value:super.getDataFee(),hardfork:this.common.hardfork()}),super.getDataFee())}getUpfrontCost(){return this.gasLimit*this.gasPrice+this.value}hash(){if(!this.isSigned()){const e=this._errorMsg("Cannot call hash method if transaction is not signed");throw new Error(e)}return Object.isFrozen(this)?(this.cache.hash||(this.cache.hash=o.from((0,i.keccak256)(n.RLP.encode((0,s.bufArrToArr)(this.raw()))))),this.cache.hash):o.from((0,i.keccak256)(n.RLP.encode((0,s.bufArrToArr)(this.raw()))))}getMessageToVerifySignature(){if(!this.isSigned()){const e=this._errorMsg("This transaction is not signed");throw new Error(e)}const e=this._getMessageToSign();return o.from((0,i.keccak256)(n.RLP.encode((0,s.bufArrToArr)(e))))}getSenderPublicKey(){const e=this.getMessageToVerifySignature(),{v:t,r:r,s:o}=this;this._validateHighS();try{return(0,s.ecrecover)(e,t,(0,s.bigIntToUnpaddedBuffer)(r),(0,s.bigIntToUnpaddedBuffer)(o),this.supports(c.Capability.EIP155ReplayProtection)?this.common.chainId():void 0)}catch(n){const e=this._errorMsg("Invalid Signature");throw new Error(e)}}_processSignature(e,t,r){this.supports(c.Capability.EIP155ReplayProtection)&&(e+=this.common.chainId()*BigInt(2)+BigInt(8));const o={...this.txOptions,common:this.common};return d.fromTxData({nonce:this.nonce,gasPrice:this.gasPrice,gasLimit:this.gasLimit,to:this.to,value:this.value,data:this.data,v:e,r:(0,s.bufferToBigInt)(t),s:(0,s.bufferToBigInt)(r)},o)}toJSON(){return{nonce:(0,s.bigIntToHex)(this.nonce),gasPrice:(0,s.bigIntToHex)(this.gasPrice),gasLimit:(0,s.bigIntToHex)(this.gasLimit),to:void 0!==this.to?this.to.toString():void 0,value:(0,s.bigIntToHex)(this.value),data:"0x"+this.data.toString("hex"),v:void 0!==this.v?(0,s.bigIntToHex)(this.v):void 0,r:void 0!==this.r?(0,s.bigIntToHex)(this.r):void 0,s:void 0!==this.s?(0,s.bigIntToHex)(this.s):void 0}}_validateTxV(e,t){let r;const o=void 0!==e?Number(e):void 0;if(void 0!==o&&o<37&&27!==o&&28!==o)throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${o}`);if(void 0!==o&&0!==o&&(!t||t.gteHardfork("spuriousDragon"))&&27!==o&&28!==o)if(t){if(!f(BigInt(o),t.chainId()))throw new Error(`Incompatible EIP155-based V ${o} and chain id ${t.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`)}else{let e;e=(o-35)%2==0?35:36,r=BigInt(o-e)/BigInt(2)}return this._getCommon(t,r)}errorStr(){let e=this._getSharedErrorPostfix();return e+=` gasPrice=${this.gasPrice}`,e}_errorMsg(e){return`${e} (${this.errorStr()})`}}t.Transaction=d},68065:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.TransactionFactory=void 0;const n=r(68683),s=r(26889),i=r(91675),a=r(77976),c=r(19426);class f{constructor(){}static fromTxData(e,t={}){if("type"in e&&void 0!==e.type){const r=Number((0,n.bufferToBigInt)((0,n.toBuffer)(e.type)));if(0===r)return c.Transaction.fromTxData(e,t);if(1===r)return i.AccessListEIP2930Transaction.fromTxData(e,t);if(2===r)return s.FeeMarketEIP1559Transaction.fromTxData(e,t);throw new Error(`Tx instantiation with type ${r} not supported`)}return c.Transaction.fromTxData(e,t)}static fromSerializedData(e,t={}){if(!(e[0]<=127))return c.Transaction.fromSerializedTx(e,t);switch(e[0]){case 1:return i.AccessListEIP2930Transaction.fromSerializedTx(e,t);case 2:return s.FeeMarketEIP1559Transaction.fromSerializedTx(e,t);default:throw new Error(`TypedTransaction with ID ${e[0]} unknown`)}}static fromBlockBodyData(e,t={}){if(o.isBuffer(e))return this.fromSerializedData(e,t);if(Array.isArray(e))return c.Transaction.fromValuesArray(e,t);throw new Error("Cannot decode transaction: unknown type input")}static async fromEthersProvider(e,t,r){const o=(0,n.getProvider)(e),s=await(0,n.fetchFromProvider)(o,{method:"eth_getTransactionByHash",params:[t]});if(null===s)throw new Error("No data returned from provider");return f.fromRPCTx(s,r)}static async fromRPCTx(e,t={}){return f.fromTxData((0,a.normalizeTxParams)(e),t)}}t.TransactionFactory=f},62418:(e,t)=>{"use strict";function r(e){if(0===e.length)return!0;const t=e[0];return!!Array.isArray(t)}Object.defineProperty(t,"__esModule",{value:!0}),t.isAccessList=t.isAccessListBuffer=t.Capability=void 0,function(e){e[e.EIP155ReplayProtection=155]="EIP155ReplayProtection",e[e.EIP1559FeeMarket=1559]="EIP1559FeeMarket",e[e.EIP2718TypedTransaction=2718]="EIP2718TypedTransaction",e[e.EIP2930AccessLists=2930]="EIP2930AccessLists"}(t.Capability||(t.Capability={})),t.isAccessListBuffer=r,t.isAccessList=function(e){return!r(e)}},58843:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AccessLists=t.checkMaxInitCodeSize=void 0;const o=r(68683),n=r(62418);t.checkMaxInitCodeSize=function(e,t){const r=e.param("vm","maxInitCodeSize");if(r&&BigInt(t)>r)throw new Error(`the initcode size of this transaction is too large: it is ${t} while the max is ${e.param("vm","maxInitCodeSize")}`)};t.AccessLists=class{static getAccessListData(e){let t,r;if((0,n.isAccessList)(e)){t=e;const n=[];for(let t=0;t<e.length;t++){const r=e[t],s=(0,o.toBuffer)(r.address),i=[];for(let e=0;e<r.storageKeys.length;e++)i.push((0,o.toBuffer)(r.storageKeys[e]));n.push([s,i])}r=n}else{r=e??[];const n=[];for(let e=0;e<r.length;e++){const t=r[e],s=(0,o.bufferToHex)(t[0]),i=[];for(let e=0;e<t[1].length;e++)i.push((0,o.bufferToHex)(t[1][e]));const a={address:s,storageKeys:i};n.push(a)}t=n}return{AccessListJSON:t,accessList:r}}static verifyAccessList(e){for(let t=0;t<e.length;t++){const r=e[t],o=r[0],n=r[1];if(void 0!==r[2])throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");if(20!==o.length)throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");for(let e=0;e<n.length;e++)if(32!==n[e].length)throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes")}}static getAccessListJSON(e){const t=[];for(let r=0;r<e.length;r++){const n=e[r],s={address:"0x"+(0,o.setLengthLeft)(n[0],20).toString("hex"),storageKeys:[]},i=n[1];for(let e=0;e<i.length;e++){const t=i[e];s.storageKeys.push("0x"+(0,o.setLengthLeft)(t,32).toString("hex"))}t.push(s)}return t}static getDataFeeEIP2930(e,t){const r=t.param("gasPrices","accessListStorageKeyCost"),o=t.param("gasPrices","accessListAddressCost");let n=0;for(let s=0;s<e.length;s++){n+=e[s][1].length}return e.length*Number(o)+n*Number(r)}}},16284:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.accountBodyToRLP=t.accountBodyToSlim=t.accountBodyFromSlim=t.isZeroAddress=t.zeroAddress=t.importPublic=t.privateToAddress=t.privateToPublic=t.publicToAddress=t.pubToAddress=t.isValidPublic=t.isValidPrivate=t.generateAddress2=t.generateAddress=t.isValidChecksumAddress=t.toChecksumAddress=t.isValidAddress=t.Account=void 0;const n=r(66289),s=r(32019),i=r(26513),a=r(82672),c=r(77312),f=r(89838),d=r(35546),u=r(59498),h=BigInt(0);class l{constructor(e=h,t=h,r=f.KECCAK256_RLP,o=f.KECCAK256_NULL){this.nonce=e,this.balance=t,this.storageRoot=r,this.codeHash=o,this._validate()}static fromAccountData(e){const{nonce:t,balance:r,storageRoot:o,codeHash:n}=e;return new l(void 0!==t?(0,c.bufferToBigInt)((0,c.toBuffer)(t)):void 0,void 0!==r?(0,c.bufferToBigInt)((0,c.toBuffer)(r)):void 0,void 0!==o?(0,c.toBuffer)(o):void 0,void 0!==n?(0,c.toBuffer)(n):void 0)}static fromRlpSerializedAccount(e){const t=(0,c.arrToBufArr)(n.RLP.decode(Uint8Array.from(e)));if(!Array.isArray(t))throw new Error("Invalid serialized account input. Must be array");return this.fromValuesArray(t)}static fromValuesArray(e){const[t,r,o,n]=e;return new l((0,c.bufferToBigInt)(t),(0,c.bufferToBigInt)(r),o,n)}_validate(){if(this.nonce<h)throw new Error("nonce must be greater than zero");if(this.balance<h)throw new Error("balance must be greater than zero");if(32!==this.storageRoot.length)throw new Error("storageRoot must have a length of 32");if(32!==this.codeHash.length)throw new Error("codeHash must have a length of 32")}raw(){return[(0,c.bigIntToUnpaddedBuffer)(this.nonce),(0,c.bigIntToUnpaddedBuffer)(this.balance),this.storageRoot,this.codeHash]}serialize(){return o.from(n.RLP.encode((0,c.bufArrToArr)(this.raw())))}isContract(){return!this.codeHash.equals(f.KECCAK256_NULL)}isEmpty(){return this.balance===h&&this.nonce===h&&this.codeHash.equals(f.KECCAK256_NULL)}}t.Account=l;t.isValidAddress=function(e){try{(0,d.assertIsString)(e)}catch(t){return!1}return/^0x[0-9a-fA-F]{40}$/.test(e)};t.toChecksumAddress=function(e,t){(0,d.assertIsHexString)(e);const r=(0,u.stripHexPrefix)(e).toLowerCase();let n="";if(void 0!==t){n=(0,c.bufferToBigInt)((0,c.toBuffer)(t)).toString()+"0x"}const i=o.from(n+r,"utf8"),f=(0,a.bytesToHex)((0,s.keccak256)(i));let h="0x";for(let o=0;o<r.length;o++)parseInt(f[o],16)>=8?h+=r[o].toUpperCase():h+=r[o];return h};t.isValidChecksumAddress=function(e,r){return(0,t.isValidAddress)(e)&&(0,t.toChecksumAddress)(e,r)===e};t.generateAddress=function(e,t){return(0,d.assertIsBuffer)(e),(0,d.assertIsBuffer)(t),(0,c.bufferToBigInt)(t)===BigInt(0)?o.from((0,s.keccak256)(n.RLP.encode((0,c.bufArrToArr)([e,null])))).slice(-20):o.from((0,s.keccak256)(n.RLP.encode((0,c.bufArrToArr)([e,t])))).slice(-20)};t.generateAddress2=function(e,t,r){if((0,d.assertIsBuffer)(e),(0,d.assertIsBuffer)(t),(0,d.assertIsBuffer)(r),20!==e.length)throw new Error("Expected from to be of length 20");if(32!==t.length)throw new Error("Expected salt to be of length 32");const n=(0,s.keccak256)(o.concat([o.from("ff","hex"),e,t,(0,s.keccak256)(r)]));return(0,c.toBuffer)(n).slice(-20)};t.isValidPrivate=function(e){return i.secp256k1.utils.isValidPrivateKey(e)};t.isValidPublic=function(e,t=!1){if((0,d.assertIsBuffer)(e),64===e.length)try{return i.secp256k1.ProjectivePoint.fromHex(o.concat([o.from([4]),e])),!0}catch(r){return!1}if(!t)return!1;try{return i.secp256k1.ProjectivePoint.fromHex(e),!0}catch(r){return!1}};t.pubToAddress=function(e,t=!1){if((0,d.assertIsBuffer)(e),t&&64!==e.length&&(e=o.from(i.secp256k1.ProjectivePoint.fromHex(e).toRawBytes(!1).slice(1))),64!==e.length)throw new Error("Expected pubKey to be of length 64");return o.from((0,s.keccak256)(e)).slice(-20)},t.publicToAddress=t.pubToAddress;t.privateToPublic=function(e){return(0,d.assertIsBuffer)(e),o.from(i.secp256k1.ProjectivePoint.fromPrivateKey(e).toRawBytes(!1).slice(1))};t.privateToAddress=function(e){return(0,t.publicToAddress)((0,t.privateToPublic)(e))};t.importPublic=function(e){return(0,d.assertIsBuffer)(e),64!==e.length&&(e=o.from(i.secp256k1.ProjectivePoint.fromHex(e).toRawBytes(!1).slice(1))),e};t.zeroAddress=function(){const e=(0,c.zeros)(20);return(0,c.bufferToHex)(e)};function p(e){const[t,r,o,n]=e;return[t,r,0===(0,c.arrToBufArr)(o).length?f.KECCAK256_RLP:o,0===(0,c.arrToBufArr)(n).length?f.KECCAK256_NULL:n]}t.isZeroAddress=function(e){try{(0,d.assertIsString)(e)}catch(r){return!1}return(0,t.zeroAddress)()===e},t.accountBodyFromSlim=p;const m=new Uint8Array(0);t.accountBodyToSlim=function(e){const[t,r,o,n]=e;return[t,r,(0,c.arrToBufArr)(o).equals(f.KECCAK256_RLP)?m:o,(0,c.arrToBufArr)(n).equals(f.KECCAK256_NULL)?m:n]},t.accountBodyToRLP=function(e,t=!0){const r=t?p(e):e;return(0,c.arrToBufArr)(n.RLP.encode(r))}},86727:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.Address=void 0;const n=r(16284),s=r(77312);class i{constructor(e){if(20!==e.length)throw new Error("Invalid address length");this.buf=e}static zero(){return new i((0,s.zeros)(20))}static fromString(e){if(!(0,n.isValidAddress)(e))throw new Error("Invalid address");return new i((0,s.toBuffer)(e))}static fromPublicKey(e){if(!o.isBuffer(e))throw new Error("Public key should be Buffer");const t=(0,n.pubToAddress)(e);return new i(t)}static fromPrivateKey(e){if(!o.isBuffer(e))throw new Error("Private key should be Buffer");const t=(0,n.privateToAddress)(e);return new i(t)}static generate(e,t){if("bigint"!=typeof t)throw new Error("Expected nonce to be a bigint");return new i((0,n.generateAddress)(e.buf,(0,s.bigIntToBuffer)(t)))}static generate2(e,t,r){if(!o.isBuffer(t))throw new Error("Expected salt to be a Buffer");if(!o.isBuffer(r))throw new Error("Expected initCode to be a Buffer");return new i((0,n.generateAddress2)(e.buf,t,r))}equals(e){return this.buf.equals(e.buf)}isZero(){return this.equals(i.zero())}isPrecompileOrSystemAddress(){const e=(0,s.bufferToBigInt)(this.buf),t=BigInt(0),r=BigInt("0xffff");return e>=t&&e<=r}toString(){return"0x"+this.buf.toString("hex")}toBuffer(){return o.from(this.buf)}}t.Address=i},98421:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AsyncEventEmitter=void 0;const o=r(37007);class n extends o.EventEmitter{emit(e,...t){let[r,o]=t;const n=this;let s=n._events[e]??[];return void 0===o&&"function"==typeof r&&(o=r,r=void 0),"newListener"!==e&&"removeListener"!==e||(r={event:r,fn:o},o=void 0),s=Array.isArray(s)?s:[s],async function(e,t,r){let o;for await(const s of t)try{s.length<2?s.call(e,r):await new Promise(((t,o)=>{s.call(e,r,(e=>{e?o(e):t()}))}))}catch(n){o=n}if(o)throw o}(n,s.slice(),r).then(o).catch(o),n.listenerCount(e)>0}once(e,t){const r=this;let o;if("function"!=typeof t)throw new TypeError("listener must be a function");return o=t.length>=2?function(n,s){r.removeListener(e,o),t(n,s)}:function(n){r.removeListener(e,o),t(n,o)},r.on(e,o),r}first(e,t){let r=this._events[e]??[];if("function"!=typeof t)throw new TypeError("listener must be a function");return Array.isArray(r)||(this._events[e]=r=[r]),r.unshift(t),this}before(e,t,r){return this.beforeOrAfter(e,t,r)}after(e,t,r){return this.beforeOrAfter(e,t,r,"after")}beforeOrAfter(e,t,r,o){let n,s,i=this._events[e]??[];const a="after"===o?1:0;if("function"!=typeof r)throw new TypeError("listener must be a function");if("function"!=typeof t)throw new TypeError("target must be a function");for(Array.isArray(i)||(this._events[e]=i=[i]),s=i.length,n=i.length;n--;)if(i[n]===t){s=n+a;break}return i.splice(s,0,r),this}on(e,t){return super.on(e,t)}addListener(e,t){return super.addListener(e,t)}prependListener(e,t){return super.prependListener(e,t)}prependOnceListener(e,t){return super.prependOnceListener(e,t)}removeAllListeners(e){return super.removeAllListeners(e)}removeListener(e,t){return super.removeListener(e,t)}eventNames(){return super.eventNames()}listeners(e){return super.listeners(e)}listenerCount(e){return super.listenerCount(e)}getMaxListeners(){return super.getMaxListeners()}setMaxListeners(e){return super.setMaxListeners(e)}}t.AsyncEventEmitter=n},77312:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.intToUnpaddedBuffer=t.bigIntToUnpaddedBuffer=t.bigIntToHex=t.bufArrToArr=t.arrToBufArr=t.validateNoLeadingZeroes=t.baToJSON=t.toUtf8=t.short=t.addHexPrefix=t.toUnsigned=t.fromSigned=t.bufferToInt=t.bigIntToBuffer=t.bufferToBigInt=t.bufferToHex=t.toBuffer=t.unpadHexString=t.unpadArray=t.unpadBuffer=t.setLengthRight=t.setLengthLeft=t.zeros=t.intToBuffer=t.intToHex=void 0;const n=r(35546),s=r(59498);t.intToHex=function(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Received an invalid integer type: ${e}`);return`0x${e.toString(16)}`};t.intToBuffer=function(e){const r=(0,t.intToHex)(e);return o.from((0,s.padToEven)(r.slice(2)),"hex")};t.zeros=function(e){return o.allocUnsafe(e).fill(0)};const i=function(e,r,o){const n=(0,t.zeros)(r);return o?e.length<r?(e.copy(n),n):e.slice(0,r):e.length<r?(e.copy(n,r-e.length),n):e.slice(-r)};t.setLengthLeft=function(e,t){return(0,n.assertIsBuffer)(e),i(e,t,!1)};t.setLengthRight=function(e,t){return(0,n.assertIsBuffer)(e),i(e,t,!0)};const a=function(e){let t=e[0];for(;e.length>0&&"0"===t.toString();)t=(e=e.slice(1))[0];return e};t.unpadBuffer=function(e){return(0,n.assertIsBuffer)(e),a(e)};t.unpadArray=function(e){return(0,n.assertIsArray)(e),a(e)};t.unpadHexString=function(e){return(0,n.assertIsHexString)(e),e=(0,s.stripHexPrefix)(e),"0x"+a(e)};t.toBuffer=function(e){if(null==e)return o.allocUnsafe(0);if(o.isBuffer(e))return o.from(e);if(Array.isArray(e)||e instanceof Uint8Array)return o.from(e);if("string"==typeof e){if(!(0,s.isHexString)(e))throw new Error(`Cannot convert string to buffer. toBuffer only supports 0x-prefixed hex strings and this string was given: ${e}`);return o.from((0,s.padToEven)((0,s.stripHexPrefix)(e)),"hex")}if("number"==typeof e)return(0,t.intToBuffer)(e);if("bigint"==typeof e){if(e<BigInt(0))throw new Error(`Cannot convert negative bigint to buffer. Given: ${e}`);let t=e.toString(16);return t.length%2&&(t="0"+t),o.from(t,"hex")}if(e.toArray)return o.from(e.toArray());if(e.toBuffer)return o.from(e.toBuffer());throw new Error("invalid type")};function c(e){const r=(0,t.bufferToHex)(e);return"0x"===r?BigInt(0):BigInt(r)}function f(e){return(0,t.toBuffer)("0x"+e.toString(16))}t.bufferToHex=function(e){return"0x"+(e=(0,t.toBuffer)(e)).toString("hex")},t.bufferToBigInt=c,t.bigIntToBuffer=f;t.bufferToInt=function(e){const t=Number(c(e));if(!Number.isSafeInteger(t))throw new Error("Number exceeds 53 bits");return t};t.fromSigned=function(e){return BigInt.asIntN(256,c(e))};t.toUnsigned=function(e){return f(BigInt.asUintN(256,e))};t.addHexPrefix=function(e){return"string"!=typeof e||(0,s.isHexPrefixed)(e)?e:"0x"+e},t.short=function(e,t=50){const r=o.isBuffer(e)?e.toString("hex"):e;return r.length<=t?r:r.slice(0,t)+"\u2026"};t.toUtf8=function(e){if((e=(0,s.stripHexPrefix)(e)).length%2!=0)throw new Error("Invalid non-even hex string input for toUtf8() provided");return o.from(e.replace(/^(00)+|(00)+$/g,""),"hex").toString("utf8")};t.baToJSON=function(e){if(o.isBuffer(e))return`0x${e.toString("hex")}`;if(e instanceof Array){const r=[];for(let o=0;o<e.length;o++)r.push((0,t.baToJSON)(e[o]));return r}};t.validateNoLeadingZeroes=function(e){for(const[t,r]of Object.entries(e))if(void 0!==r&&r.length>0&&0===r[0])throw new Error(`${t} cannot have leading zeroes, received: ${r.toString("hex")}`)},t.arrToBufArr=function e(t){return Array.isArray(t)?t.map((t=>e(t))):o.from(t)},t.bufArrToArr=function e(t){return Array.isArray(t)?t.map((t=>e(t))):Uint8Array.from(t??[])};t.bigIntToHex=e=>"0x"+e.toString(16),t.bigIntToUnpaddedBuffer=function(e){return(0,t.unpadBuffer)(f(e))},t.intToUnpaddedBuffer=function(e){return(0,t.unpadBuffer)((0,t.intToBuffer)(e))}},89838:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MAX_WITHDRAWALS_PER_PAYLOAD=t.RLP_EMPTY_STRING=t.KECCAK256_RLP=t.KECCAK256_RLP_S=t.KECCAK256_RLP_ARRAY=t.KECCAK256_RLP_ARRAY_S=t.KECCAK256_NULL=t.KECCAK256_NULL_S=t.TWO_POW256=t.SECP256K1_ORDER_DIV_2=t.SECP256K1_ORDER=t.MAX_INTEGER_BIGINT=t.MAX_INTEGER=t.MAX_UINT64=void 0;const o=r(48287),n=r(26513);t.MAX_UINT64=BigInt("0xffffffffffffffff"),t.MAX_INTEGER=BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),t.MAX_INTEGER_BIGINT=BigInt("115792089237316195423570985008687907853269984665640564039457584007913129639935"),t.SECP256K1_ORDER=n.secp256k1.CURVE.n,t.SECP256K1_ORDER_DIV_2=n.secp256k1.CURVE.n/BigInt(2),t.TWO_POW256=BigInt("0x10000000000000000000000000000000000000000000000000000000000000000"),t.KECCAK256_NULL_S="c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470",t.KECCAK256_NULL=o.Buffer.from(t.KECCAK256_NULL_S,"hex"),t.KECCAK256_RLP_ARRAY_S="1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347",t.KECCAK256_RLP_ARRAY=o.Buffer.from(t.KECCAK256_RLP_ARRAY_S,"hex"),t.KECCAK256_RLP_S="56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421",t.KECCAK256_RLP=o.Buffer.from(t.KECCAK256_RLP_S,"hex"),t.RLP_EMPTY_STRING=o.Buffer.from([128]),t.MAX_WITHDRAWALS_PER_PAYLOAD=16},45062:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.compactBytesToNibbles=t.bytesToNibbles=t.nibblesToCompactBytes=t.nibblesToBytes=t.hasTerminator=void 0;t.hasTerminator=e=>e.length>0&&16===e[e.length-1];t.nibblesToBytes=(e,t)=>{for(let r=0,o=0;o<e.length;r+=1,o+=2)t[r]=e[o]<<4|e[o+1]};t.nibblesToCompactBytes=e=>{let r=0;(0,t.hasTerminator)(e)&&(r=1,e=e.subarray(0,e.length-1));const o=new Uint8Array(e.length/2+1);return o[0]=r<<5,1==(1&e.length)&&(o[0]|=16,o[0]|=e[0],e=e.subarray(1)),(0,t.nibblesToBytes)(e,o.subarray(1)),o};t.bytesToNibbles=e=>{const t=2*e.length+1,r=new Uint8Array(t);for(let o=0;o<e.length;o++){const t=e[o];r[2*o]=t/16,r[2*o+1]=t%16}return r[t-1]=16,r};t.compactBytesToNibbles=e=>{if(0===e.length)return e;let r=(0,t.bytesToNibbles)(e);r[0]<2&&(r=r.subarray(0,r.length-1));const o=2-(1&r[0]);return r.subarray(o)}},35546:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.assertIsString=t.assertIsArray=t.assertIsBuffer=t.assertIsHexString=void 0;const n=r(59498);t.assertIsHexString=function(e){if(!(0,n.isHexString)(e)){throw new Error(`This method only supports 0x-prefixed hex strings but input was: ${e}`)}};t.assertIsBuffer=function(e){if(!o.isBuffer(e)){throw new Error(`This method only supports Buffer but input was: ${e}`)}};t.assertIsArray=function(e){if(!Array.isArray(e)){throw new Error(`This method only supports number arrays but input was: ${e}`)}};t.assertIsString=function(e){if("string"!=typeof e){throw new Error(`This method only supports strings but input was: ${e}`)}}},68683:function(e,t,r){"use strict";var o=this&&this.__createBinding||(Object.create?function(e,t,r,o){void 0===o&&(o=r);var n=Object.getOwnPropertyDescriptor(t,r);n&&!("get"in n?!t.__esModule:n.writable||n.configurable)||(n={enumerable:!0,get:function(){return t[r]}}),Object.defineProperty(e,o,n)}:function(e,t,r,o){void 0===o&&(o=r),e[o]=t[r]}),n=this&&this.__exportStar||function(e,t){for(var r in e)"default"===r||Object.prototype.hasOwnProperty.call(t,r)||o(t,e,r)};Object.defineProperty(t,"__esModule",{value:!0}),t.toAscii=t.stripHexPrefix=t.padToEven=t.isHexString=t.isHexPrefixed=t.getKeys=t.getBinarySize=t.fromUtf8=t.fromAscii=t.arrayContainsArray=void 0,n(r(89838),t),n(r(52652),t),n(r(16284),t),n(r(86727),t),n(r(37380),t),n(r(92133),t),n(r(77312),t),n(r(42666),t),n(r(45062),t),n(r(98421),t);var s=r(59498);Object.defineProperty(t,"arrayContainsArray",{enumerable:!0,get:function(){return s.arrayContainsArray}}),Object.defineProperty(t,"fromAscii",{enumerable:!0,get:function(){return s.fromAscii}}),Object.defineProperty(t,"fromUtf8",{enumerable:!0,get:function(){return s.fromUtf8}}),Object.defineProperty(t,"getBinarySize",{enumerable:!0,get:function(){return s.getBinarySize}}),Object.defineProperty(t,"getKeys",{enumerable:!0,get:function(){return s.getKeys}}),Object.defineProperty(t,"isHexPrefixed",{enumerable:!0,get:function(){return s.isHexPrefixed}}),Object.defineProperty(t,"isHexString",{enumerable:!0,get:function(){return s.isHexString}}),Object.defineProperty(t,"padToEven",{enumerable:!0,get:function(){return s.padToEven}}),Object.defineProperty(t,"stripHexPrefix",{enumerable:!0,get:function(){return s.stripHexPrefix}}),Object.defineProperty(t,"toAscii",{enumerable:!0,get:function(){return s.toAscii}}),n(r(31708),t),n(r(81862),t)},59498:(e,t,r)=>{"use strict";var o=r(48287).Buffer;function n(e){if("string"!=typeof e)throw new Error("[isHexPrefixed] input must be type 'string', received type "+typeof e);return"0"===e[0]&&"x"===e[1]}Object.defineProperty(t,"__esModule",{value:!0}),t.isHexString=t.getKeys=t.fromAscii=t.fromUtf8=t.toAscii=t.arrayContainsArray=t.getBinarySize=t.padToEven=t.stripHexPrefix=t.isHexPrefixed=void 0,t.isHexPrefixed=n;function s(e){let t=e;if("string"!=typeof t)throw new Error("[padToEven] value must be type 'string', received "+typeof t);return t.length%2&&(t=`0${t}`),t}t.stripHexPrefix=e=>{if("string"!=typeof e)throw new Error("[stripHexPrefix] input must be type 'string', received "+typeof e);return n(e)?e.slice(2):e},t.padToEven=s,t.getBinarySize=function(e){if("string"!=typeof e)throw new Error("[getBinarySize] method requires input type 'string', received "+typeof e);return o.byteLength(e,"utf8")},t.arrayContainsArray=function(e,t,r){if(!0!==Array.isArray(e))throw new Error(`[arrayContainsArray] method requires input 'superset' to be an array, got type '${typeof e}'`);if(!0!==Array.isArray(t))throw new Error(`[arrayContainsArray] method requires input 'subset' to be an array, got type '${typeof t}'`);return t[!0===r?"some":"every"]((t=>e.indexOf(t)>=0))},t.toAscii=function(e){let t="",r=0;const o=e.length;for("0x"===e.substring(0,2)&&(r=2);r<o;r+=2){const o=parseInt(e.substr(r,2),16);t+=String.fromCharCode(o)}return t},t.fromUtf8=function(e){return`0x${s(o.from(e,"utf8").toString("hex")).replace(/^0+|0+$/g,"")}`},t.fromAscii=function(e){let t="";for(let r=0;r<e.length;r++){const o=e.charCodeAt(r).toString(16);t+=o.length<2?`0${o}`:o}return`0x${t}`},t.getKeys=function(e,t,r){if(!Array.isArray(e))throw new Error("[getKeys] method expects input 'params' to be an array, got "+typeof e);if("string"!=typeof t)throw new Error("[getKeys] method expects input 'key' to be type 'string', got "+typeof e);const o=[];for(let n=0;n<e.length;n++){let s=e[n][t];if(!0!==r||s){if("string"!=typeof s)throw new Error("invalid abi - expected type 'string', received "+typeof s)}else s="";o.push(s)}return o},t.isHexString=function(e,t){return!("string"!=typeof e||!e.match(/^0x[0-9A-Fa-f]*$/))&&!(void 0!==t&&t>0&&e.length!==2+2*t)}},31708:(e,t,r)=>{"use strict";var o=r(96763);Object.defineProperty(t,"__esModule",{value:!0}),t.Lock=void 0;t.Lock=class{constructor(){this.permits=1,this.promiseResolverQueue=[]}async acquire(){return this.permits>0?(this.permits-=1,Promise.resolve(!0)):new Promise((e=>this.promiseResolverQueue.push(e)))}release(){if(this.permits+=1,this.permits>1&&this.promiseResolverQueue.length>0)o.warn("Lock.permits should never be > 0 when there is someone waiting.");else if(1===this.permits&&this.promiseResolverQueue.length>0){this.permits-=1;const e=this.promiseResolverQueue.shift();e&&e(!0)}}}},81862:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.getProvider=t.fetchFromProvider=void 0;const o=r(6215);t.fetchFromProvider=async(e,t)=>(await(0,o.default)(e,{headers:{"content-type":"application/json"},type:"json",data:{method:t.method,params:t.params,jsonrpc:"2.0",id:1}})).result;t.getProvider=e=>{if("string"==typeof e)return e;if(void 0!==e?.connection?.url)return e.connection.url;throw new Error("Must provide valid provider URL or Web3Provider")}},92133:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.hashPersonalMessage=t.isValidSignature=t.fromRpcSig=t.toCompactSig=t.toRpcSig=t.ecrecover=t.ecsign=void 0;const n=r(32019),s=r(26513),i=r(77312),a=r(89838),c=r(35546);function f(e,t){return e===BigInt(0)||e===BigInt(1)?e:void 0===t?e-BigInt(27):e-(t*BigInt(2)+BigInt(35))}function d(e){return e===BigInt(0)||e===BigInt(1)}t.ecsign=function(e,t,r){const n=s.secp256k1.sign(e,t),i=n.toCompactRawBytes();return{r:o.from(i.slice(0,32)),s:o.from(i.slice(32,64)),v:void 0===r?BigInt(n.recovery+27):BigInt(n.recovery+35)+BigInt(r)*BigInt(2)}};t.ecrecover=function(e,t,r,n,a){const c=o.concat([(0,i.setLengthLeft)(r,32),(0,i.setLengthLeft)(n,32)],64),u=f(t,a);if(!d(u))throw new Error("Invalid signature v value");const h=s.secp256k1.Signature.fromCompact(c).addRecoveryBit(Number(u)).recoverPublicKey(e);return o.from(h.toRawBytes(!1).slice(1))};t.toRpcSig=function(e,t,r,n){if(!d(f(e,n)))throw new Error("Invalid signature v value");return(0,i.bufferToHex)(o.concat([(0,i.setLengthLeft)(t,32),(0,i.setLengthLeft)(r,32),(0,i.toBuffer)(e)]))};t.toCompactSig=function(e,t,r,n){if(!d(f(e,n)))throw new Error("Invalid signature v value");let s=r;return(e>BigInt(28)&&e%BigInt(2)===BigInt(1)||e===BigInt(1)||e===BigInt(28))&&(s=o.from(r),s[0]|=128),(0,i.bufferToHex)(o.concat([(0,i.setLengthLeft)(t,32),(0,i.setLengthLeft)(s,32)]))};t.fromRpcSig=function(e){const t=(0,i.toBuffer)(e);let r,o,n;if(t.length>=65)r=t.slice(0,32),o=t.slice(32,64),n=(0,i.bufferToBigInt)(t.slice(64));else{if(64!==t.length)throw new Error("Invalid signature length");r=t.slice(0,32),o=t.slice(32,64),n=BigInt((0,i.bufferToInt)(t.slice(32,33))>>7),o[0]&=127}return n<27&&(n+=BigInt(27)),{v:n,r:r,s:o}};t.isValidSignature=function(e,t,r,o=!0,n){if(32!==t.length||32!==r.length)return!1;if(!d(f(e,n)))return!1;const s=(0,i.bufferToBigInt)(t),c=(0,i.bufferToBigInt)(r);return!(s===BigInt(0)||s>=a.SECP256K1_ORDER||c===BigInt(0)||c>=a.SECP256K1_ORDER)&&!(o&&c>=a.SECP256K1_ORDER_DIV_2)};t.hashPersonalMessage=function(e){(0,c.assertIsBuffer)(e);const t=o.from(`\x19Ethereum Signed Message:\n${e.length}`,"utf-8");return o.from((0,n.keccak256)(o.concat([t,e])))}},42666:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.toType=t.TypeOutput=void 0;const o=r(77312),n=r(59498);var s;!function(e){e[e.Number=0]="Number",e[e.BigInt=1]="BigInt",e[e.Buffer=2]="Buffer",e[e.PrefixedHexString=3]="PrefixedHexString"}(s=t.TypeOutput||(t.TypeOutput={})),t.toType=function(e,t){if(null===e)return null;if(void 0===e)return;if("string"==typeof e&&!(0,n.isHexString)(e))throw new Error(`A string must be provided with a 0x-prefix, given: ${e}`);if("number"==typeof e&&!Number.isSafeInteger(e))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");const r=(0,o.toBuffer)(e);switch(t){case s.Buffer:return r;case s.BigInt:return(0,o.bufferToBigInt)(r);case s.Number:{const e=(0,o.bufferToBigInt)(r);if(e>BigInt(Number.MAX_SAFE_INTEGER))throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");return Number(e)}case s.PrefixedHexString:return(0,o.bufferToHex)(r);default:throw new Error("unknown outputType")}}},52652:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.GWEI_TO_WEI=void 0,t.GWEI_TO_WEI=BigInt(1e9)},37380:(e,t,r)=>{"use strict";var o=r(48287).Buffer;Object.defineProperty(t,"__esModule",{value:!0}),t.Withdrawal=void 0;const n=r(86727),s=r(77312),i=r(42666);class a{constructor(e,t,r,o){this.index=e,this.validatorIndex=t,this.address=r,this.amount=o}static fromWithdrawalData(e){const{index:t,validatorIndex:r,address:o,amount:s}=e,c=(0,i.toType)(t,i.TypeOutput.BigInt),f=(0,i.toType)(r,i.TypeOutput.BigInt),d=new n.Address((0,i.toType)(o,i.TypeOutput.Buffer)),u=(0,i.toType)(s,i.TypeOutput.BigInt);return new a(c,f,d,u)}static fromValuesArray(e){if(4!==e.length)throw Error(`Invalid withdrawalArray length expected=4 actual=${e.length}`);const[t,r,o,n]=e;return a.fromWithdrawalData({index:t,validatorIndex:r,address:o,amount:n})}static toBufferArray(e){const{index:t,validatorIndex:r,address:s,amount:a}=e,c=(0,i.toType)(t,i.TypeOutput.BigInt)===BigInt(0)?o.alloc(0):(0,i.toType)(t,i.TypeOutput.Buffer),f=(0,i.toType)(r,i.TypeOutput.BigInt)===BigInt(0)?o.alloc(0):(0,i.toType)(r,i.TypeOutput.Buffer);let d;d=s instanceof n.Address?s.buf:(0,i.toType)(s,i.TypeOutput.Buffer);return[c,f,d,(0,i.toType)(a,i.TypeOutput.BigInt)===BigInt(0)?o.alloc(0):(0,i.toType)(a,i.TypeOutput.Buffer)]}raw(){return a.toBufferArray(this)}toValue(){return{index:this.index,validatorIndex:this.validatorIndex,address:this.address.buf,amount:this.amount}}toJSON(){return{index:(0,s.bigIntToHex)(this.index),validatorIndex:(0,s.bigIntToHex)(this.validatorIndex),address:"0x"+this.address.buf.toString("hex"),amount:(0,s.bigIntToHex)(this.amount)}}}t.Withdrawal=a},73562:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createCurve=t.getHash=void 0;const o=r(39615),n=r(99175),s=r(91705);function i(e){return{hash:e,hmac:(t,...r)=>(0,o.hmac)(e,t,(0,n.concatBytes)(...r)),randomBytes:n.randomBytes}}t.getHash=i,t.createCurve=function(e,t){const r=t=>(0,s.weierstrass)({...e,...i(t)});return Object.freeze({...r(t),create:r})}},62422:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.validateBasic=t.wNAF=void 0;const o=r(24967),n=r(91484),s=BigInt(0),i=BigInt(1);t.wNAF=function(e,t){const r=(e,t)=>{const r=t.negate();return e?r:t},o=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:r,unsafeLadder(t,r){let o=e.ZERO,n=t;for(;r>s;)r&i&&(o=o.add(n)),n=n.double(),r>>=i;return o},precomputeWindow(e,t){const{windows:r,windowSize:n}=o(t),s=[];let i=e,a=i;for(let o=0;o<r;o++){a=i,s.push(a);for(let e=1;e<n;e++)a=a.add(i),s.push(a);i=a.double()}return s},wNAF(t,n,s){const{windows:a,windowSize:c}=o(t);let f=e.ZERO,d=e.BASE;const u=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let e=0;e<a;e++){const t=e*c;let o=Number(s&u);s>>=l,o>c&&(o-=h,s+=i);const a=t,p=t+Math.abs(o)-1,m=e%2!=0,g=o<0;0===o?d=d.add(r(m,n[a])):f=f.add(r(g,n[p]))}return{p:f,f:d}},wNAFCached(e,t,r,o){const n=e._WINDOW_SIZE||1;let s=t.get(e);return s||(s=this.precomputeWindow(e,n),1!==n&&t.set(e,o(s))),this.wNAF(n,s,r)}}},t.validateBasic=function(e){return(0,o.validateField)(e.Fp),(0,n.validateObject)(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...(0,o.nLength)(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}},71761:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.createHasher=t.isogenyMap=t.hash_to_field=t.expand_message_xof=t.expand_message_xmd=void 0;const o=r(24967),n=r(91484);const s=n.bytesToNumberBE;function i(e,t){if(e<0||e>=1<<8*t)throw new Error(`bad I2OSP call: value=${e} length=${t}`);const r=Array.from({length:t}).fill(0);for(let o=t-1;o>=0;o--)r[o]=255&e,e>>>=8;return new Uint8Array(r)}function a(e,t){const r=new Uint8Array(e.length);for(let o=0;o<e.length;o++)r[o]=e[o]^t[o];return r}function c(e){if(!(0,n.isBytes)(e))throw new Error("Uint8Array expected")}function f(e){if(!Number.isSafeInteger(e))throw new Error("number expected")}function d(e,t,r,o){c(e),c(t),f(r),t.length>255&&(t=o((0,n.concatBytes)((0,n.utf8ToBytes)("H2C-OVERSIZE-DST-"),t)));const{outputLen:s,blockLen:d}=o,u=Math.ceil(r/s);if(u>255)throw new Error("Invalid xmd length");const h=(0,n.concatBytes)(t,i(t.length,1)),l=i(0,d),p=i(r,2),m=new Array(u),g=o((0,n.concatBytes)(l,e,p,i(0,1),h));m[0]=o((0,n.concatBytes)(g,i(1,1),h));for(let c=1;c<=u;c++){const e=[a(g,m[c-1]),i(c+1,1),h];m[c]=o((0,n.concatBytes)(...e))}return(0,n.concatBytes)(...m).slice(0,r)}function u(e,t,r,o,s){if(c(e),c(t),f(r),t.length>255){const e=Math.ceil(2*o/8);t=s.create({dkLen:e}).update((0,n.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(t).digest()}if(r>65535||t.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:r}).update(e).update(i(r,2)).update(t).update(i(t.length,1)).digest()}function h(e,t,r){(0,n.validateObject)(r,{DST:"stringOrUint8Array",p:"bigint",m:"isSafeInteger",k:"isSafeInteger",hash:"hash"});const{p:i,k:a,m:h,hash:l,expand:p,DST:m}=r;c(e),f(t);const g=function(e){if((0,n.isBytes)(e))return e;if("string"==typeof e)return(0,n.utf8ToBytes)(e);throw new Error("DST must be Uint8Array or string")}(m),b=i.toString(2).length,y=Math.ceil((b+a)/8),v=t*h*y;let w;if("xmd"===p)w=d(e,g,v,l);else if("xof"===p)w=u(e,g,v,a,l);else{if("_internal_pass"!==p)throw new Error('expand must be "xmd" or "xof"');w=e}const E=new Array(t);for(let n=0;n<t;n++){const e=new Array(h);for(let t=0;t<h;t++){const r=y*(t+n*h),a=w.subarray(r,r+y);e[t]=(0,o.mod)(s(a),i)}E[n]=e}return E}t.expand_message_xmd=d,t.expand_message_xof=u,t.hash_to_field=h,t.isogenyMap=function(e,t){const r=t.map((e=>Array.from(e).reverse()));return(t,o)=>{const[n,s,i,a]=r.map((r=>r.reduce(((r,o)=>e.add(e.mul(r,t),o)))));return t=e.div(n,s),o=e.mul(o,e.div(i,a)),{x:t,y:o}}},t.createHasher=function(e,t,r){if("function"!=typeof t)throw new Error("mapToCurve() must be defined");return{hashToCurve(o,n){const s=h(o,2,{...r,DST:r.DST,...n}),i=e.fromAffine(t(s[0])),a=e.fromAffine(t(s[1])),c=i.add(a).clearCofactor();return c.assertValidity(),c},encodeToCurve(o,n){const s=h(o,1,{...r,DST:r.encodeDST,...n}),i=e.fromAffine(t(s[0])).clearCofactor();return i.assertValidity(),i}}}},24967:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mapHashToField=t.getMinHashLength=t.getFieldBytesLength=t.hashToPrivateScalar=t.FpSqrtEven=t.FpSqrtOdd=t.Field=t.nLength=t.FpIsSquare=t.FpDiv=t.FpInvertBatch=t.FpPow=t.validateField=t.isNegativeLE=t.FpSqrt=t.tonelliShanks=t.invert=t.pow2=t.pow=t.mod=void 0;const o=r(91484),n=BigInt(0),s=BigInt(1),i=BigInt(2),a=BigInt(3),c=BigInt(4),f=BigInt(5),d=BigInt(8);BigInt(9),BigInt(16);function u(e,t){const r=e%t;return r>=n?r:t+r}function h(e,t,r){if(r<=n||t<n)throw new Error("Expected power/modulo > 0");if(r===s)return n;let o=s;for(;t>n;)t&s&&(o=o*e%r),e=e*e%r,t>>=s;return o}function l(e,t){if(e===n||t<=n)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=u(e,t),o=t,i=n,a=s,c=s,f=n;for(;r!==n;){const e=o/r,t=o%r,n=i-c*e,s=a-f*e;o=r,r=t,i=c,a=f,c=n,f=s}if(o!==s)throw new Error("invert: does not exist");return u(i,t)}function p(e){const t=(e-s)/i;let r,o,a;for(r=e-s,o=0;r%i===n;r/=i,o++);for(a=i;a<e&&h(a,t,e)!==e-s;a++);if(1===o){const t=(e+s)/c;return function(e,r){const o=e.pow(r,t);if(!e.eql(e.sqr(o),r))throw new Error("Cannot find square root");return o}}const f=(r+s)/i;return function(e,n){if(e.pow(n,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let i=o,c=e.pow(e.mul(e.ONE,a),r),d=e.pow(n,f),u=e.pow(n,r);for(;!e.eql(u,e.ONE);){if(e.eql(u,e.ZERO))return e.ZERO;let t=1;for(let o=e.sqr(u);t<i&&!e.eql(o,e.ONE);t++)o=e.sqr(o);const r=e.pow(c,s<<BigInt(i-t-1));c=e.sqr(r),d=e.mul(d,r),u=e.mul(u,c),i=t}return d}}function m(e){if(e%c===a){const t=(e+s)/c;return function(e,r){const o=e.pow(r,t);if(!e.eql(e.sqr(o),r))throw new Error("Cannot find square root");return o}}if(e%d===f){const t=(e-f)/d;return function(e,r){const o=e.mul(r,i),n=e.pow(o,t),s=e.mul(r,n),a=e.mul(e.mul(s,i),n),c=e.mul(s,e.sub(a,e.ONE));if(!e.eql(e.sqr(c),r))throw new Error("Cannot find square root");return c}}return p(e)}t.mod=u,t.pow=h,t.pow2=function(e,t,r){let o=e;for(;t-- >n;)o*=o,o%=r;return o},t.invert=l,t.tonelliShanks=p,t.FpSqrt=m;t.isNegativeLE=(e,t)=>(u(e,t)&s)===s;const g=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function b(e,t,r){if(r<n)throw new Error("Expected power > 0");if(r===n)return e.ONE;if(r===s)return t;let o=e.ONE,i=t;for(;r>n;)r&s&&(o=e.mul(o,i)),i=e.sqr(i),r>>=s;return o}function y(e,t){const r=new Array(t.length),o=t.reduce(((t,o,n)=>e.is0(o)?t:(r[n]=t,e.mul(t,o))),e.ONE),n=e.inv(o);return t.reduceRight(((t,o,n)=>e.is0(o)?t:(r[n]=e.mul(t,r[n]),e.mul(t,o))),n),r}function v(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function w(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function E(e){const t=w(e);return t+Math.ceil(t/2)}t.validateField=function(e){const t=g.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"});return(0,o.validateObject)(e,t)},t.FpPow=b,t.FpInvertBatch=y,t.FpDiv=function(e,t,r){return e.mul(t,"bigint"==typeof r?l(r,e.ORDER):e.inv(r))},t.FpIsSquare=function(e){const t=(e.ORDER-s)/i;return r=>{const o=e.pow(r,t);return e.eql(o,e.ZERO)||e.eql(o,e.ONE)}},t.nLength=v,t.Field=function(e,t,r=!1,i={}){if(e<=n)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:a,nByteLength:c}=v(e,t);if(c>2048)throw new Error("Field lengths over 2048 bytes are not supported");const f=m(e),d=Object.freeze({ORDER:e,BITS:a,BYTES:c,MASK:(0,o.bitMask)(a),ZERO:n,ONE:s,create:t=>u(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return n<=t&&t<e},is0:e=>e===n,isOdd:e=>(e&s)===s,neg:t=>u(-t,e),eql:(e,t)=>e===t,sqr:t=>u(t*t,e),add:(t,r)=>u(t+r,e),sub:(t,r)=>u(t-r,e),mul:(t,r)=>u(t*r,e),pow:(e,t)=>b(d,e,t),div:(t,r)=>u(t*l(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>l(t,e),sqrt:i.sqrt||(e=>f(d,e)),invertBatch:e=>y(d,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?(0,o.numberToBytesLE)(e,c):(0,o.numberToBytesBE)(e,c),fromBytes:e=>{if(e.length!==c)throw new Error(`Fp.fromBytes: expected ${c}, got ${e.length}`);return r?(0,o.bytesToNumberLE)(e):(0,o.bytesToNumberBE)(e)}});return Object.freeze(d)},t.FpSqrtOdd=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?r:e.neg(r)},t.FpSqrtEven=function(e,t){if(!e.isOdd)throw new Error("Field doesn't have isOdd");const r=e.sqrt(t);return e.isOdd(r)?e.neg(r):r},t.hashToPrivateScalar=function(e,t,r=!1){const n=(e=(0,o.ensureBytes)("privateHash",e)).length,i=v(t).nByteLength+8;if(i<24||n<i||n>1024)throw new Error(`hashToPrivateScalar: expected ${i}-1024 bytes of input, got ${n}`);return u(r?(0,o.bytesToNumberLE)(e):(0,o.bytesToNumberBE)(e),t-s)+s},t.getFieldBytesLength=w,t.getMinHashLength=E,t.mapHashToField=function(e,t,r=!1){const n=e.length,i=w(t),a=E(t);if(n<16||n<a||n>1024)throw new Error(`expected ${a}-1024 bytes of input, got ${n}`);const c=u(r?(0,o.bytesToNumberBE)(e):(0,o.bytesToNumberLE)(e),t-s)+s;return r?(0,o.numberToBytesLE)(c,i):(0,o.numberToBytesBE)(c,i)}},91484:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.validateObject=t.createHmacDrbg=t.bitMask=t.bitSet=t.bitGet=t.bitLen=t.utf8ToBytes=t.equalBytes=t.concatBytes=t.ensureBytes=t.numberToVarBytesBE=t.numberToBytesLE=t.numberToBytesBE=t.bytesToNumberLE=t.bytesToNumberBE=t.hexToBytes=t.hexToNumber=t.numberToHexUnpadded=t.bytesToHex=t.isBytes=void 0;const r=BigInt(0),o=BigInt(1),n=BigInt(2);function s(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}t.isBytes=s;const i=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function a(e){if(!s(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=i[e[r]];return t}function c(e){const t=e.toString(16);return 1&t.length?`0${t}`:t}function f(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}t.bytesToHex=a,t.numberToHexUnpadded=c,t.hexToNumber=f;const d={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function u(e){return e>=d._0&&e<=d._9?e-d._0:e>=d._A&&e<=d._F?e-(d._A-10):e>=d._a&&e<=d._f?e-(d._a-10):void 0}function h(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const o=new Uint8Array(r);for(let n=0,s=0;n<r;n++,s+=2){const t=u(e.charCodeAt(s)),r=u(e.charCodeAt(s+1));if(void 0===t||void 0===r){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}o[n]=16*t+r}return o}function l(e,t){return h(e.toString(16).padStart(2*t,"0"))}function p(...e){let t=0;for(let n=0;n<e.length;n++){const r=e[n];if(!s(r))throw new Error("Uint8Array expected");t+=r.length}let r=new Uint8Array(t),o=0;for(let n=0;n<e.length;n++){const t=e[n];r.set(t,o),o+=t.length}return r}t.hexToBytes=h,t.bytesToNumberBE=function(e){return f(a(e))},t.bytesToNumberLE=function(e){if(!s(e))throw new Error("Uint8Array expected");return f(a(Uint8Array.from(e).reverse()))},t.numberToBytesBE=l,t.numberToBytesLE=function(e,t){return l(e,t).reverse()},t.numberToVarBytesBE=function(e){return h(c(e))},t.ensureBytes=function(e,t,r){let o;if("string"==typeof t)try{o=h(t)}catch(i){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${i}`)}else{if(!s(t))throw new Error(`${e} must be hex string or Uint8Array`);o=Uint8Array.from(t)}const n=o.length;if("number"==typeof r&&n!==r)throw new Error(`${e} expected ${r} bytes, got ${n}`);return o},t.concatBytes=p,t.equalBytes=function(e,t){if(e.length!==t.length)return!1;let r=0;for(let o=0;o<e.length;o++)r|=e[o]^t[o];return 0===r},t.utf8ToBytes=function(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))},t.bitLen=function(e){let t;for(t=0;e>r;e>>=o,t+=1);return t},t.bitGet=function(e,t){return e>>BigInt(t)&o};t.bitSet=(e,t,n)=>e|(n?o:r)<<BigInt(t);t.bitMask=e=>(n<<BigInt(e-1))-o;const m=e=>new Uint8Array(e),g=e=>Uint8Array.from(e);t.createHmacDrbg=function(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let o=m(e),n=m(e),s=0;const i=()=>{o.fill(1),n.fill(0),s=0},a=(...e)=>r(n,o,...e),c=(e=m())=>{n=a(g([0]),e),o=a(),0!==e.length&&(n=a(g([1]),e),o=a())},f=()=>{if(s++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){o=a();const t=o.slice();r.push(t),e+=o.length}return p(...r)};return(e,t)=>{let r;for(i(),c(e);!(r=t(f()));)c();return i(),r}};const b={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||s(e),isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};t.validateObject=function(e,t,r={}){const o=(t,r,o)=>{const n=b[r];if("function"!=typeof n)throw new Error(`Invalid validator "${r}", expected function`);const s=e[t];if(!(o&&void 0===s||n(s,e)))throw new Error(`Invalid param ${String(t)}=${s} (${typeof s}), expected ${r}`)};for(const[n,s]of Object.entries(t))o(n,s,!1);for(const[n,s]of Object.entries(r))o(n,s,!0);return e}},91705:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.mapToCurveSimpleSWU=t.SWUFpSqrtRatio=t.weierstrass=t.weierstrassPoints=t.DER=void 0;const o=r(24967),n=r(91484),s=r(91484),i=r(62422);const{bytesToNumberBE:a,hexToBytes:c}=n;t.DER={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:r}=t.DER;if(e.length<2||2!==e[0])throw new r("Invalid signature integer tag");const o=e[1],n=e.subarray(2,o+2);if(!o||n.length!==o)throw new r("Invalid signature integer: wrong length");if(128&n[0])throw new r("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new r("Invalid signature integer: unnecessary leading zero");return{d:a(n),l:e.subarray(o+2)}},toSig(e){const{Err:r}=t.DER,o="string"==typeof e?c(e):e;if(!n.isBytes(o))throw new Error("ui8a expected");let s=o.length;if(s<2||48!=o[0])throw new r("Invalid signature tag");if(o[1]!==s-2)throw new r("Invalid signature: incorrect length");const{d:i,l:a}=t.DER._parseInt(o.subarray(2)),{d:f,l:d}=t.DER._parseInt(a);if(d.length)throw new r("Invalid signature: left bytes after parsing");return{r:i,s:f}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,r=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},o=t(r(e.s)),n=t(r(e.r)),s=o.length/2,i=n.length/2,a=r(s),c=r(i);return`30${r(i+s+4)}02${c}${n}02${a}${o}`}};const f=BigInt(0),d=BigInt(1),u=BigInt(2),h=BigInt(3),l=BigInt(4);function p(e){const t=function(e){const t=(0,i.validateBasic)(e);n.validateObject(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:o,a:s}=t;if(r){if(!o.eql(s,o.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,a=t.toBytes||((e,t,o)=>{const s=t.toAffine();return n.concatBytes(Uint8Array.from([4]),r.toBytes(s.x),r.toBytes(s.y))}),c=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function u(e){const{a:o,b:n}=t,s=r.sqr(e),i=r.mul(s,e);return r.add(r.add(i,r.mul(e,o)),n)}if(!r.eql(r.sqr(t.Gy),u(t.Gx)))throw new Error("bad generator point: equation left != right");function l(e){return"bigint"==typeof e&&f<e&&e<t.n}function p(e){if(!l(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function m(e){const{allowedPrivateKeyLengths:r,nByteLength:i,wrapPrivateKey:a,n:c}=t;if(r&&"bigint"!=typeof e){if(n.isBytes(e)&&(e=n.bytesToHex(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*i,"0")}let f;try{f="bigint"==typeof e?e:n.bytesToNumberBE((0,s.ensureBytes)("private key",e,i))}catch(d){throw new Error(`private key must be ${i} bytes, hex or bigint, not ${typeof e}`)}return a&&(f=o.mod(f,c)),p(f),f}const g=new Map;function b(e){if(!(e instanceof y))throw new Error("ProjectivePoint expected")}class y{constructor(e,t,o){if(this.px=e,this.py=t,this.pz=o,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==o||!r.isValid(o))throw new Error("z required")}static fromAffine(e){const{x:t,y:o}=e||{};if(!e||!r.isValid(t)||!r.isValid(o))throw new Error("invalid affine point");if(e instanceof y)throw new Error("projective point not allowed");const n=e=>r.eql(e,r.ZERO);return n(t)&&n(o)?y.ZERO:new y(t,o,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(y.fromAffine)}static fromHex(e){const t=y.fromAffine(c((0,s.ensureBytes)("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return y.BASE.multiply(m(e))}_setWindowSize(e){this._WINDOW_SIZE=e,g.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:o}=this.toAffine();if(!r.isValid(e)||!r.isValid(o))throw new Error("bad point: x or y not FE");const n=r.sqr(o),s=u(e);if(!r.eql(n,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){b(e);const{px:t,py:o,pz:n}=this,{px:s,py:i,pz:a}=e,c=r.eql(r.mul(t,a),r.mul(s,n)),f=r.eql(r.mul(o,a),r.mul(i,n));return c&&f}negate(){return new y(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:o}=t,n=r.mul(o,h),{px:s,py:i,pz:a}=this;let c=r.ZERO,f=r.ZERO,d=r.ZERO,u=r.mul(s,s),l=r.mul(i,i),p=r.mul(a,a),m=r.mul(s,i);return m=r.add(m,m),d=r.mul(s,a),d=r.add(d,d),c=r.mul(e,d),f=r.mul(n,p),f=r.add(c,f),c=r.sub(l,f),f=r.add(l,f),f=r.mul(c,f),c=r.mul(m,c),d=r.mul(n,d),p=r.mul(e,p),m=r.sub(u,p),m=r.mul(e,m),m=r.add(m,d),d=r.add(u,u),u=r.add(d,u),u=r.add(u,p),u=r.mul(u,m),f=r.add(f,u),p=r.mul(i,a),p=r.add(p,p),u=r.mul(p,m),c=r.sub(c,u),d=r.mul(p,l),d=r.add(d,d),d=r.add(d,d),new y(c,f,d)}add(e){b(e);const{px:o,py:n,pz:s}=this,{px:i,py:a,pz:c}=e;let f=r.ZERO,d=r.ZERO,u=r.ZERO;const l=t.a,p=r.mul(t.b,h);let m=r.mul(o,i),g=r.mul(n,a),v=r.mul(s,c),w=r.add(o,n),E=r.add(i,a);w=r.mul(w,E),E=r.add(m,g),w=r.sub(w,E),E=r.add(o,s);let B=r.add(i,c);return E=r.mul(E,B),B=r.add(m,v),E=r.sub(E,B),B=r.add(n,s),f=r.add(a,c),B=r.mul(B,f),f=r.add(g,v),B=r.sub(B,f),u=r.mul(l,E),f=r.mul(p,v),u=r.add(f,u),f=r.sub(g,u),u=r.add(g,u),d=r.mul(f,u),g=r.add(m,m),g=r.add(g,m),v=r.mul(l,v),E=r.mul(p,E),g=r.add(g,v),v=r.sub(m,v),v=r.mul(l,v),E=r.add(E,v),m=r.mul(g,E),d=r.add(d,m),m=r.mul(B,E),f=r.mul(w,f),f=r.sub(f,m),m=r.mul(w,g),u=r.mul(B,u),u=r.add(u,m),new y(f,d,u)}subtract(e){return this.add(e.negate())}is0(){return this.equals(y.ZERO)}wNAF(e){return w.wNAFCached(this,g,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(y.fromAffine)}))}multiplyUnsafe(e){const o=y.ZERO;if(e===f)return o;if(p(e),e===d)return this;const{endo:n}=t;if(!n)return w.unsafeLadder(this,e);let{k1neg:s,k1:i,k2neg:a,k2:c}=n.splitScalar(e),u=o,h=o,l=this;for(;i>f||c>f;)i&d&&(u=u.add(l)),c&d&&(h=h.add(l)),l=l.double(),i>>=d,c>>=d;return s&&(u=u.negate()),a&&(h=h.negate()),h=new y(r.mul(h.px,n.beta),h.py,h.pz),u.add(h)}multiply(e){p(e);let o,n,s=e;const{endo:i}=t;if(i){const{k1neg:e,k1:t,k2neg:a,k2:c}=i.splitScalar(s);let{p:f,f:d}=this.wNAF(t),{p:u,f:h}=this.wNAF(c);f=w.constTimeNegate(e,f),u=w.constTimeNegate(a,u),u=new y(r.mul(u.px,i.beta),u.py,u.pz),o=f.add(u),n=d.add(h)}else{const{p:e,f:t}=this.wNAF(s);o=e,n=t}return y.normalizeZ([o,n])[0]}multiplyAndAddUnsafe(e,t,r){const o=y.BASE,n=(e,t)=>t!==f&&t!==d&&e.equals(o)?e.multiply(t):e.multiplyUnsafe(t),s=n(this,t).add(n(e,r));return s.is0()?void 0:s}toAffine(e){const{px:t,py:o,pz:n}=this,s=this.is0();null==e&&(e=s?r.ONE:r.inv(n));const i=r.mul(t,e),a=r.mul(o,e),c=r.mul(n,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:i,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===d)return!0;if(r)return r(y,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===d?this:r?r(y,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),a(y,this,e)}toHex(e=!0){return n.bytesToHex(this.toRawBytes(e))}}y.BASE=new y(t.Gx,t.Gy,r.ONE),y.ZERO=new y(r.ZERO,r.ONE,r.ZERO);const v=t.nBitLength,w=(0,i.wNAF)(y,t.endo?Math.ceil(v/2):v);return{CURVE:t,ProjectivePoint:y,normPrivateKeyToScalar:m,weierstrassEquation:u,isWithinCurveOrder:l}}function m(e,t){const r=e.ORDER;let o=f;for(let h=r-d;h%u===f;h/=u)o+=d;const n=o,s=u<<n-d-d,i=s*u,a=(r-d)/i,c=(a-d)/u,p=i-d,m=s,g=e.pow(t,a),b=e.pow(t,(a+d)/u);let y=(t,r)=>{let o=g,s=e.pow(r,p),i=e.sqr(s);i=e.mul(i,r);let a=e.mul(t,i);a=e.pow(a,c),a=e.mul(a,s),s=e.mul(a,r),i=e.mul(a,t);let f=e.mul(i,s);a=e.pow(f,m);let h=e.eql(a,e.ONE);s=e.mul(i,b),a=e.mul(f,o),i=e.cmov(s,i,h),f=e.cmov(a,f,h);for(let c=n;c>d;c--){let t=c-u;t=u<<t-d;let r=e.pow(f,t);const n=e.eql(r,e.ONE);s=e.mul(i,o),o=e.mul(o,o),r=e.mul(f,o),i=e.cmov(s,i,n),f=e.cmov(r,f,n)}return{isValid:h,value:i}};if(e.ORDER%l===h){const r=(e.ORDER-h)/l,o=e.sqrt(e.neg(t));y=(t,n)=>{let s=e.sqr(n);const i=e.mul(t,n);s=e.mul(s,i);let a=e.pow(s,r);a=e.mul(a,i);const c=e.mul(a,o),f=e.mul(e.sqr(a),n),d=e.eql(f,t);return{isValid:d,value:e.cmov(c,a,d)}}}return y}t.weierstrassPoints=p,t.weierstrass=function(e){const r=function(e){const t=(0,i.validateBasic)(e);return n.validateObject(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:a,n:c}=r,u=a.BYTES+1,h=2*a.BYTES+1;function l(e){return o.mod(e,c)}function m(e){return o.invert(e,c)}const{ProjectivePoint:g,normPrivateKeyToScalar:b,weierstrassEquation:y,isWithinCurveOrder:v}=p({...r,toBytes(e,t,r){const o=t.toAffine(),s=a.toBytes(o.x),i=n.concatBytes;return r?i(Uint8Array.from([t.hasEvenY()?2:3]),s):i(Uint8Array.from([4]),s,a.toBytes(o.y))},fromBytes(e){const t=e.length,r=e[0],o=e.subarray(1);if(t!==u||2!==r&&3!==r){if(t===h&&4===r){return{x:a.fromBytes(o.subarray(0,a.BYTES)),y:a.fromBytes(o.subarray(a.BYTES,2*a.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${u} compressed bytes or ${h} uncompressed bytes`)}{const e=n.bytesToNumberBE(o);if(!(f<(s=e)&&s<a.ORDER))throw new Error("Point is not on curve");const t=y(e);let i=a.sqrt(t);return 1==(1&r)!==((i&d)===d)&&(i=a.neg(i)),{x:e,y:i}}var s}}),w=e=>n.bytesToHex(n.numberToBytesBE(e,r.nByteLength));function E(e){return e>c>>d}const B=(e,t,r)=>n.bytesToNumberBE(e.slice(t,r));class x{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const t=r.nByteLength;return e=(0,s.ensureBytes)("compactSignature",e,2*t),new x(B(e,0,t),B(e,t,2*t))}static fromDER(e){const{r:r,s:o}=t.DER.toSig((0,s.ensureBytes)("DER",e));return new x(r,o)}assertValidity(){if(!v(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!v(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new x(this.r,this.s,e)}recoverPublicKey(e){const{r:t,s:o,recovery:n}=this,i=P((0,s.ensureBytes)("msgHash",e));if(null==n||![0,1,2,3].includes(n))throw new Error("recovery id invalid");const c=2===n||3===n?t+r.n:t;if(c>=a.ORDER)throw new Error("recovery id 2 or 3 invalid");const f=0==(1&n)?"02":"03",d=g.fromHex(f+w(c)),u=m(c),h=l(-i*u),p=l(o*u),b=g.BASE.multiplyAndAddUnsafe(d,h,p);if(!b)throw new Error("point at infinify");return b.assertValidity(),b}hasHighS(){return E(this.s)}normalizeS(){return this.hasHighS()?new x(this.r,l(-this.s),this.recovery):this}toDERRawBytes(){return n.hexToBytes(this.toDERHex())}toDERHex(){return t.DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return n.hexToBytes(this.toCompactHex())}toCompactHex(){return w(this.r)+w(this.s)}}const k={isValidPrivateKey(e){try{return b(e),!0}catch(t){return!1}},normPrivateKeyToScalar:b,randomPrivateKey:()=>{const e=o.getMinHashLength(r.n);return o.mapHashToField(r.randomBytes(e),r.n)},precompute:(e=8,t=g.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function I(e){const t=n.isBytes(e),r="string"==typeof e,o=(t||r)&&e.length;return t?o===u||o===h:r?o===2*u||o===2*h:e instanceof g}const T=r.bits2int||function(e){const t=n.bytesToNumberBE(e),o=8*e.length-r.nBitLength;return o>0?t>>BigInt(o):t},P=r.bits2int_modN||function(e){return l(T(e))},S=n.bitMask(r.nBitLength);function A(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(f<=e&&e<S))throw new Error(`bigint expected < 2^${r.nBitLength}`);return n.numberToBytesBE(e,r.nByteLength)}function _(e,t,o=O){if(["recovered","canonical"].some((e=>e in o)))throw new Error("sign() legacy options not supported");const{hash:i,randomBytes:c}=r;let{lowS:u,prehash:h,extraEntropy:p}=o;null==u&&(u=!0),e=(0,s.ensureBytes)("msgHash",e),h&&(e=(0,s.ensureBytes)("prehashed msgHash",i(e)));const y=P(e),w=b(t),B=[A(w),A(y)];if(null!=p){const e=!0===p?c(a.BYTES):p;B.push((0,s.ensureBytes)("extraEntropy",e))}const k=n.concatBytes(...B),I=y;return{seed:k,k2sig:function(e){const t=T(e);if(!v(t))return;const r=m(t),o=g.BASE.multiply(t).toAffine(),n=l(o.x);if(n===f)return;const s=l(r*l(I+n*w));if(s===f)return;let i=(o.x===n?0:2)|Number(o.y&d),a=s;return u&&E(s)&&(a=function(e){return E(e)?l(-e):e}(s),i^=1),new x(n,a,i)}}}const O={lowS:r.lowS,prehash:!1},C={lowS:r.lowS,prehash:!1};return g.BASE._setWindowSize(8),{CURVE:r,getPublicKey:function(e,t=!0){return g.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(I(e))throw new Error("first arg must be private key");if(!I(t))throw new Error("second arg must be public key");return g.fromHex(t).multiply(b(e)).toRawBytes(r)},sign:function(e,t,o=O){const{seed:s,k2sig:i}=_(e,t,o),a=r;return n.createHmacDrbg(a.hash.outputLen,a.nByteLength,a.hmac)(s,i)},verify:function(e,o,i,a=C){const c=e;if(o=(0,s.ensureBytes)("msgHash",o),i=(0,s.ensureBytes)("publicKey",i),"strict"in a)throw new Error("options.strict was renamed to lowS");const{lowS:f,prehash:d}=a;let u,h;try{if("string"==typeof c||n.isBytes(c))try{u=x.fromDER(c)}catch(k){if(!(k instanceof t.DER.Err))throw k;u=x.fromCompact(c)}else{if("object"!=typeof c||"bigint"!=typeof c.r||"bigint"!=typeof c.s)throw new Error("PARSE");{const{r:e,s:t}=c;u=new x(e,t)}}h=g.fromHex(i)}catch(I){if("PARSE"===I.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(f&&u.hasHighS())return!1;d&&(o=r.hash(o));const{r:p,s:b}=u,y=P(o),v=m(b),w=l(y*v),E=l(p*v),B=g.BASE.multiplyAndAddUnsafe(h,w,E)?.toAffine();return!!B&&l(B.x)===p},ProjectivePoint:g,Signature:x,utils:k}},t.SWUFpSqrtRatio=m,t.mapToCurveSimpleSWU=function(e,t){if(o.validateField(e),!e.isValid(t.A)||!e.isValid(t.B)||!e.isValid(t.Z))throw new Error("mapToCurveSimpleSWU: invalid opts");const r=m(e,t.Z);if(!e.isOdd)throw new Error("Fp.isOdd is not implemented!");return o=>{let n,s,i,a,c,f,d,u;n=e.sqr(o),n=e.mul(n,t.Z),s=e.sqr(n),s=e.add(s,n),i=e.add(s,e.ONE),i=e.mul(i,t.B),a=e.cmov(t.Z,e.neg(s),!e.eql(s,e.ZERO)),a=e.mul(a,t.A),s=e.sqr(i),f=e.sqr(a),c=e.mul(f,t.A),s=e.add(s,c),s=e.mul(s,i),f=e.mul(f,a),c=e.mul(f,t.B),s=e.add(s,c),d=e.mul(n,i);const{isValid:h,value:l}=r(s,f);u=e.mul(n,o),u=e.mul(u,l),d=e.cmov(d,i,h),u=e.cmov(u,l,h);const p=e.isOdd(o)===e.isOdd(u);return u=e.cmov(e.neg(u),u,p),d=e.div(d,a),{x:d,y:u}}}},8510:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.encodeToCurve=t.hashToCurve=t.schnorr=t.secp256k1=void 0;const o=r(22623),n=r(99175),s=r(24967),i=r(91705),a=r(91484),c=r(71761),f=r(73562),d=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),u=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h=BigInt(1),l=BigInt(2),p=(e,t)=>(e+t/l)/t;function m(e){const t=d,r=BigInt(3),o=BigInt(6),n=BigInt(11),i=BigInt(22),a=BigInt(23),c=BigInt(44),f=BigInt(88),u=e*e*e%t,h=u*u*e%t,p=(0,s.pow2)(h,r,t)*h%t,m=(0,s.pow2)(p,r,t)*h%t,b=(0,s.pow2)(m,l,t)*u%t,y=(0,s.pow2)(b,n,t)*b%t,v=(0,s.pow2)(y,i,t)*y%t,w=(0,s.pow2)(v,c,t)*v%t,E=(0,s.pow2)(w,f,t)*w%t,B=(0,s.pow2)(E,c,t)*v%t,x=(0,s.pow2)(B,r,t)*h%t,k=(0,s.pow2)(x,a,t)*y%t,I=(0,s.pow2)(k,o,t)*u%t,T=(0,s.pow2)(I,l,t);if(!g.eql(g.sqr(T),e))throw new Error("Cannot find square root");return T}const g=(0,s.Field)(d,void 0,void 0,{sqrt:m});t.secp256k1=(0,f.createCurve)({a:BigInt(0),b:BigInt(7),Fp:g,n:u,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=u,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),o=-h*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),n=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,a=BigInt("0x100000000000000000000000000000000"),c=p(i*e,t),f=p(-o*e,t);let d=(0,s.mod)(e-c*r-f*n,t),l=(0,s.mod)(-c*o-f*i,t);const m=d>a,g=l>a;if(m&&(d=t-d),g&&(l=t-l),d>a||l>a)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:m,k1:d,k2neg:g,k2:l}}}},o.sha256);const b=BigInt(0),y=e=>"bigint"==typeof e&&b<e&&e<d,v=e=>"bigint"==typeof e&&b<e&&e<u,w={};function E(e,...t){let r=w[e];if(void 0===r){const t=(0,o.sha256)(Uint8Array.from(e,(e=>e.charCodeAt(0))));r=(0,a.concatBytes)(t,t),w[e]=r}return(0,o.sha256)((0,a.concatBytes)(r,...t))}const B=e=>e.toRawBytes(!0).slice(1),x=e=>(0,a.numberToBytesBE)(e,32),k=e=>(0,s.mod)(e,d),I=e=>(0,s.mod)(e,u),T=t.secp256k1.ProjectivePoint,P=(e,t,r)=>T.BASE.multiplyAndAddUnsafe(e,t,r);function S(e){let r=t.secp256k1.utils.normPrivateKeyToScalar(e),o=T.fromPrivateKey(r);return{scalar:o.hasEvenY()?r:I(-r),bytes:B(o)}}function A(e){if(!y(e))throw new Error("bad x: need 0 < x < p");const t=k(e*e);let r=m(k(t*e+BigInt(7)));r%l!==b&&(r=k(-r));const o=new T(e,r,h);return o.assertValidity(),o}function _(...e){return I((0,a.bytesToNumberBE)(E("BIP0340/challenge",...e)))}function O(e){return S(e).bytes}function C(e,t,r=(0,n.randomBytes)(32)){const o=(0,a.ensureBytes)("message",e),{bytes:s,scalar:i}=S(t),c=(0,a.ensureBytes)("auxRand",r,32),f=x(i^(0,a.bytesToNumberBE)(E("BIP0340/aux",c))),d=E("BIP0340/nonce",f,s,o),u=I((0,a.bytesToNumberBE)(d));if(u===b)throw new Error("sign failed: k is zero");const{bytes:h,scalar:l}=S(u),p=_(h,s,o),m=new Uint8Array(64);if(m.set(h,0),m.set(x(I(l+p*i)),32),!H(m,o,s))throw new Error("sign: Invalid signature produced");return m}function H(e,t,r){const o=(0,a.ensureBytes)("signature",e,64),n=(0,a.ensureBytes)("message",t),s=(0,a.ensureBytes)("publicKey",r,32);try{const e=A((0,a.bytesToNumberBE)(s)),t=(0,a.bytesToNumberBE)(o.subarray(0,32));if(!y(t))return!1;const r=(0,a.bytesToNumberBE)(o.subarray(32,64));if(!v(r))return!1;const i=_(x(t),B(e),n),c=P(e,r,I(-i));return!(!c||!c.hasEvenY()||c.toAffine().x!==t)}catch(i){return!1}}t.schnorr={getPublicKey:O,sign:C,verify:H,utils:{randomPrivateKey:t.secp256k1.utils.randomPrivateKey,lift_x:A,pointToBytes:B,numberToBytesBE:a.numberToBytesBE,bytesToNumberBE:a.bytesToNumberBE,taggedHash:E,mod:s.mod}};const L=(()=>(0,c.isogenyMap)(g,[["0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7","0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581","0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262","0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"],["0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b","0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14","0x0000000000000000000000000000000000000000000000000000000000000001"],["0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c","0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3","0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931","0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"],["0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b","0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573","0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f","0x0000000000000000000000000000000000000000000000000000000000000001"]].map((e=>e.map((e=>BigInt(e)))))))(),R=(()=>(0,i.mapToCurveSimpleSWU)(g,{A:BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),B:BigInt("1771"),Z:g.create(BigInt("-11"))}))(),N=(()=>(0,c.createHasher)(t.secp256k1.ProjectivePoint,(e=>{const{x:t,y:r}=R(g.create(e[0]));return L(t,r)}),{DST:"secp256k1_XMD:SHA-256_SSWU_RO_",encodeDST:"secp256k1_XMD:SHA-256_SSWU_NU_",p:g.ORDER,m:1,k:128,expand:"xmd",hash:o.sha256}))();t.hashToCurve=N.hashToCurve,t.encodeToCurve=N.encodeToCurve},67557:(e,t)=>{"use strict";function r(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function o(e){if("boolean"!=typeof e)throw new Error(`Expected boolean, not ${e}`)}function n(e,...t){if(!((r=e)instanceof Uint8Array||null!=r&&"object"==typeof r&&"Uint8Array"===r.constructor.name))throw new Error("Expected Uint8Array");var r;if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function s(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");r(e.outputLen),r(e.blockLen)}function i(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function a(e,t){n(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}Object.defineProperty(t,"__esModule",{value:!0}),t.output=t.exists=t.hash=t.bytes=t.bool=t.number=void 0,t.number=r,t.bool=o,t.bytes=n,t.hash=s,t.exists=i,t.output=a;const c={number:r,bool:o,bytes:n,hash:s,exists:i,output:a};t.default=c},90915:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SHA2=void 0;const o=r(67557),n=r(99175);class s extends n.Hash{constructor(e,t,r,o){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=o,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=(0,n.createView)(this.buffer)}update(e){(0,o.exists)(this);const{view:t,buffer:r,blockLen:s}=this,i=(e=(0,n.toBytes)(e)).length;for(let o=0;o<i;){const a=Math.min(s-this.pos,i-o);if(a!==s)r.set(e.subarray(o,o+a),this.pos),this.pos+=a,o+=a,this.pos===s&&(this.process(t,0),this.pos=0);else{const t=(0,n.createView)(e);for(;s<=i-o;o+=s)this.process(t,o)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){(0,o.exists)(this),(0,o.output)(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:s,isLE:i}=this;let{pos:a}=this;t[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let o=a;o<s;o++)t[o]=0;!function(e,t,r,o){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,o);const n=BigInt(32),s=BigInt(4294967295),i=Number(r>>n&s),a=Number(r&s),c=o?4:0,f=o?0:4;e.setUint32(t+c,i,o),e.setUint32(t+f,a,o)}(r,s-8,BigInt(8*this.length),i),this.process(r,0);const c=(0,n.createView)(e),f=this.outputLen;if(f%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const d=f/4,u=this.get();if(d>u.length)throw new Error("_sha2: outputLen bigger than state");for(let o=0;o<d;o++)c.setUint32(4*o,u[o],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:o,finished:n,destroyed:s,pos:i}=this;return e.length=o,e.pos=i,e.finished=n,e.destroyed=s,o%t&&e.buffer.set(r),e}}t.SHA2=s},22318:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.add5L=t.add5H=t.add4H=t.add4L=t.add3H=t.add3L=t.add=t.rotlBL=t.rotlBH=t.rotlSL=t.rotlSH=t.rotr32L=t.rotr32H=t.rotrBL=t.rotrBH=t.rotrSL=t.rotrSH=t.shrSL=t.shrSH=t.toBig=t.split=t.fromBig=void 0;const r=BigInt(2**32-1),o=BigInt(32);function n(e,t=!1){return t?{h:Number(e&r),l:Number(e>>o&r)}:{h:0|Number(e>>o&r),l:0|Number(e&r)}}function s(e,t=!1){let r=new Uint32Array(e.length),o=new Uint32Array(e.length);for(let s=0;s<e.length;s++){const{h:i,l:a}=n(e[s],t);[r[s],o[s]]=[i,a]}return[r,o]}t.fromBig=n,t.split=s;const i=(e,t)=>BigInt(e>>>0)<<o|BigInt(t>>>0);t.toBig=i;const a=(e,t,r)=>e>>>r;t.shrSH=a;const c=(e,t,r)=>e<<32-r|t>>>r;t.shrSL=c;const f=(e,t,r)=>e>>>r|t<<32-r;t.rotrSH=f;const d=(e,t,r)=>e<<32-r|t>>>r;t.rotrSL=d;const u=(e,t,r)=>e<<64-r|t>>>r-32;t.rotrBH=u;const h=(e,t,r)=>e>>>r-32|t<<64-r;t.rotrBL=h;const l=(e,t)=>t;t.rotr32H=l;const p=(e,t)=>e;t.rotr32L=p;const m=(e,t,r)=>e<<r|t>>>32-r;t.rotlSH=m;const g=(e,t,r)=>t<<r|e>>>32-r;t.rotlSL=g;const b=(e,t,r)=>t<<r-32|e>>>64-r;t.rotlBH=b;const y=(e,t,r)=>e<<r-32|t>>>64-r;function v(e,t,r,o){const n=(t>>>0)+(o>>>0);return{h:e+r+(n/2**32|0)|0,l:0|n}}t.rotlBL=y,t.add=v;const w=(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0);t.add3L=w;const E=(e,t,r,o)=>t+r+o+(e/2**32|0)|0;t.add3H=E;const B=(e,t,r,o)=>(e>>>0)+(t>>>0)+(r>>>0)+(o>>>0);t.add4L=B;const x=(e,t,r,o,n)=>t+r+o+n+(e/2**32|0)|0;t.add4H=x;const k=(e,t,r,o,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(o>>>0)+(n>>>0);t.add5L=k;const I=(e,t,r,o,n,s)=>t+r+o+n+s+(e/2**32|0)|0;t.add5H=I;const T={fromBig:n,split:s,toBig:i,shrSH:a,shrSL:c,rotrSH:f,rotrSL:d,rotrBH:u,rotrBL:h,rotr32H:l,rotr32L:p,rotlSH:m,rotlSL:g,rotlBH:b,rotlBL:y,add:v,add3L:w,add3H:E,add4L:B,add4H:x,add5H:I,add5L:k};t.default=T},25145:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.crypto=void 0,t.crypto="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0},39615:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.hmac=t.HMAC=void 0;const o=r(67557),n=r(99175);class s extends n.Hash{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,(0,o.hash)(e);const r=(0,n.toBytes)(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,i=new Uint8Array(s);i.set(r.length>s?e.create().update(r).digest():r);for(let o=0;o<i.length;o++)i[o]^=54;this.iHash.update(i),this.oHash=e.create();for(let o=0;o<i.length;o++)i[o]^=106;this.oHash.update(i),i.fill(0)}update(e){return(0,o.exists)(this),this.iHash.update(e),this}digestInto(e){(0,o.exists)(this),(0,o.bytes)(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:o,destroyed:n,blockLen:s,outputLen:i}=this;return e.finished=o,e.destroyed=n,e.blockLen=s,e.outputLen=i,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}t.HMAC=s;t.hmac=(e,t,r)=>new s(e,t).update(r).digest(),t.hmac.create=(e,t)=>new s(e,t)},22623:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.sha224=t.sha256=void 0;const o=r(90915),n=r(99175),s=(e,t,r)=>e&t^e&r^t&r,i=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),a=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),c=new Uint32Array(64);class f extends o.SHA2{constructor(){super(64,32,8,!1),this.A=0|a[0],this.B=0|a[1],this.C=0|a[2],this.D=0|a[3],this.E=0|a[4],this.F=0|a[5],this.G=0|a[6],this.H=0|a[7]}get(){const{A:e,B:t,C:r,D:o,E:n,F:s,G:i,H:a}=this;return[e,t,r,o,n,s,i,a]}set(e,t,r,o,n,s,i,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|o,this.E=0|n,this.F=0|s,this.G=0|i,this.H=0|a}process(e,t){for(let n=0;n<16;n++,t+=4)c[n]=e.getUint32(t,!1);for(let s=16;s<64;s++){const e=c[s-15],t=c[s-2],r=(0,n.rotr)(e,7)^(0,n.rotr)(e,18)^e>>>3,o=(0,n.rotr)(t,17)^(0,n.rotr)(t,19)^t>>>10;c[s]=o+c[s-7]+r+c[s-16]|0}let{A:r,B:o,C:a,D:f,E:d,F:u,G:h,H:l}=this;for(let m=0;m<64;m++){const e=l+((0,n.rotr)(d,6)^(0,n.rotr)(d,11)^(0,n.rotr)(d,25))+((p=d)&u^~p&h)+i[m]+c[m]|0,t=((0,n.rotr)(r,2)^(0,n.rotr)(r,13)^(0,n.rotr)(r,22))+s(r,o,a)|0;l=h,h=u,u=d,d=f+e|0,f=a,a=o,o=r,r=e+t|0}var p;r=r+this.A|0,o=o+this.B|0,a=a+this.C|0,f=f+this.D|0,d=d+this.E|0,u=u+this.F|0,h=h+this.G|0,l=l+this.H|0,this.set(r,o,a,f,d,u,h,l)}roundClean(){c.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}class d extends f{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}t.sha256=(0,n.wrapConstructor)((()=>new f)),t.sha224=(0,n.wrapConstructor)((()=>new d))},32955:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.shake256=t.shake128=t.keccak_512=t.keccak_384=t.keccak_256=t.keccak_224=t.sha3_512=t.sha3_384=t.sha3_256=t.sha3_224=t.Keccak=t.keccakP=void 0;const o=r(67557),n=r(22318),s=r(99175),[i,a,c]=[[],[],[]],f=BigInt(0),d=BigInt(1),u=BigInt(2),h=BigInt(7),l=BigInt(256),p=BigInt(113);for(let x=0,k=d,I=1,T=0;x<24;x++){[I,T]=[T,(2*I+3*T)%5],i.push(2*(5*T+I)),a.push((x+1)*(x+2)/2%64);let e=f;for(let t=0;t<7;t++)k=(k<<d^(k>>h)*p)%l,k&u&&(e^=d<<(d<<BigInt(t))-d);c.push(e)}const[m,g]=(0,n.split)(c,!0),b=(e,t,r)=>r>32?(0,n.rotlBH)(e,t,r):(0,n.rotlSH)(e,t,r),y=(e,t,r)=>r>32?(0,n.rotlBL)(e,t,r):(0,n.rotlSL)(e,t,r);function v(e,t=24){const r=new Uint32Array(10);for(let o=24-t;o<24;o++){for(let o=0;o<10;o++)r[o]=e[o]^e[o+10]^e[o+20]^e[o+30]^e[o+40];for(let o=0;o<10;o+=2){const t=(o+8)%10,n=(o+2)%10,s=r[n],i=r[n+1],a=b(s,i,1)^r[t],c=y(s,i,1)^r[t+1];for(let r=0;r<50;r+=10)e[o+r]^=a,e[o+r+1]^=c}let t=e[2],n=e[3];for(let r=0;r<24;r++){const o=a[r],s=b(t,n,o),c=y(t,n,o),f=i[r];t=e[f],n=e[f+1],e[f]=s,e[f+1]=c}for(let o=0;o<50;o+=10){for(let t=0;t<10;t++)r[t]=e[o+t];for(let t=0;t<10;t++)e[o+t]^=~r[(t+2)%10]&r[(t+4)%10]}e[0]^=m[o],e[1]^=g[o]}r.fill(0)}t.keccakP=v;class w extends s.Hash{constructor(e,t,r,n=!1,i=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=i,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,(0,o.number)(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200),this.state32=(0,s.u32)(this.state)}keccak(){v(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){(0,o.exists)(this);const{blockLen:t,state:r}=this,n=(e=(0,s.toBytes)(e)).length;for(let o=0;o<n;){const s=Math.min(t-this.pos,n-o);for(let t=0;t<s;t++)r[this.pos++]^=e[o++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:o}=this;e[r]^=t,0!=(128&t)&&r===o-1&&this.keccak(),e[o-1]^=128,this.keccak()}writeInto(e){(0,o.exists)(this,!1),(0,o.bytes)(e),this.finish();const t=this.state,{blockLen:r}=this;for(let o=0,n=e.length;o<n;){this.posOut>=r&&this.keccak();const s=Math.min(r-this.posOut,n-o);e.set(t.subarray(this.posOut,this.posOut+s),o),this.posOut+=s,o+=s}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return(0,o.number)(e),this.xofInto(new Uint8Array(e))}digestInto(e){if((0,o.output)(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:o,rounds:n,enableXOF:s}=this;return e||(e=new w(t,r,o,s,n)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=n,e.suffix=r,e.outputLen=o,e.enableXOF=s,e.destroyed=this.destroyed,e}}t.Keccak=w;const E=(e,t,r)=>(0,s.wrapConstructor)((()=>new w(t,e,r)));t.sha3_224=E(6,144,28),t.sha3_256=E(6,136,32),t.sha3_384=E(6,104,48),t.sha3_512=E(6,72,64),t.keccak_224=E(1,144,28),t.keccak_256=E(1,136,32),t.keccak_384=E(1,104,48),t.keccak_512=E(1,72,64);const B=(e,t,r)=>(0,s.wrapXOFConstructorWithOpts)(((o={})=>new w(t,e,void 0===o.dkLen?r:o.dkLen,!0)));t.shake128=B(31,168,16),t.shake256=B(31,136,32)},99175:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.randomBytes=t.wrapXOFConstructorWithOpts=t.wrapConstructorWithOpts=t.wrapConstructor=t.checkOpts=t.Hash=t.concatBytes=t.toBytes=t.utf8ToBytes=t.asyncLoop=t.nextTick=t.hexToBytes=t.bytesToHex=t.isLE=t.rotr=t.createView=t.u32=t.u8=void 0;const o=r(25145);t.u8=e=>new Uint8Array(e.buffer,e.byteOffset,e.byteLength);function n(e){return e instanceof Uint8Array||null!=e&&"object"==typeof e&&"Uint8Array"===e.constructor.name}t.u32=e=>new Uint32Array(e.buffer,e.byteOffset,Math.floor(e.byteLength/4));t.createView=e=>new DataView(e.buffer,e.byteOffset,e.byteLength);if(t.rotr=(e,t)=>e<<32-t|e>>>t,t.isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0],!t.isLE)throw new Error("Non little-endian hardware is not supported");const s=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));t.bytesToHex=function(e){if(!n(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=s[e[r]];return t};const i={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function a(e){return e>=i._0&&e<=i._9?e-i._0:e>=i._A&&e<=i._F?e-(i._A-10):e>=i._a&&e<=i._f?e-(i._a-10):void 0}t.hexToBytes=function(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length,r=t/2;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const o=new Uint8Array(r);for(let n=0,s=0;n<r;n++,s+=2){const t=a(e.charCodeAt(s)),r=a(e.charCodeAt(s+1));if(void 0===t||void 0===r){const t=e[s]+e[s+1];throw new Error('hex string expected, got non-hex character "'+t+'" at index '+s)}o[n]=16*t+r}return o};function c(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function f(e){if("string"==typeof e&&(e=c(e)),!n(e))throw new Error("expected Uint8Array, got "+typeof e);return e}t.nextTick=async()=>{},t.asyncLoop=async function(e,r,o){let n=Date.now();for(let s=0;s<e;s++){o(s);const e=Date.now()-n;e>=0&&e<r||(await(0,t.nextTick)(),n+=e)}},t.utf8ToBytes=c,t.toBytes=f,t.concatBytes=function(...e){let t=0;for(let o=0;o<e.length;o++){const r=e[o];if(!n(r))throw new Error("Uint8Array expected");t+=r.length}const r=new Uint8Array(t);for(let o=0,n=0;o<e.length;o++){const t=e[o];r.set(t,n),n+=t.length}return r};t.Hash=class{clone(){return this._cloneInto()}};const d={}.toString;t.checkOpts=function(e,t){if(void 0!==t&&"[object Object]"!==d.call(t))throw new Error("Options should be object or undefined");return Object.assign(e,t)},t.wrapConstructor=function(e){const t=t=>e().update(f(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t},t.wrapConstructorWithOpts=function(e){const t=(t,r)=>e(r).update(f(t)).digest(),r=e({});return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t},t.wrapXOFConstructorWithOpts=function(e){const t=(t,r)=>e(r).update(f(t)).digest(),r=e({});return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=t=>e(t),t},t.randomBytes=function(e=32){if(o.crypto&&"function"==typeof o.crypto.getRandomValues)return o.crypto.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}},86866:e=>{e.exports={100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",208:"Already Reported",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",508:"Loop Detected",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"}},32019:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.keccak512=t.keccak384=t.keccak256=t.keccak224=void 0;const o=r(32955),n=r(82672);t.keccak224=(0,n.wrapHash)(o.keccak_224),t.keccak256=(()=>{const e=(0,n.wrapHash)(o.keccak_256);return e.create=o.keccak_256.create,e})(),t.keccak384=(0,n.wrapHash)(o.keccak_384),t.keccak512=(0,n.wrapHash)(o.keccak_512)},26513:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.secp256k1=void 0;var o=r(8510);Object.defineProperty(t,"secp256k1",{enumerable:!0,get:function(){return o.secp256k1}})},82672:function(e,t,r){"use strict";e=r.nmd(e);var o=this&&this.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.crypto=t.wrapHash=t.equalsBytes=t.hexToBytes=t.bytesToUtf8=t.utf8ToBytes=t.createView=t.concatBytes=t.toHex=t.bytesToHex=t.assertBytes=t.assertBool=void 0;const n=o(r(67557)),s=r(99175),i=n.default.bool;t.assertBool=i;const a=n.default.bytes;t.assertBytes=a;var c=r(99175);Object.defineProperty(t,"bytesToHex",{enumerable:!0,get:function(){return c.bytesToHex}}),Object.defineProperty(t,"toHex",{enumerable:!0,get:function(){return c.bytesToHex}}),Object.defineProperty(t,"concatBytes",{enumerable:!0,get:function(){return c.concatBytes}}),Object.defineProperty(t,"createView",{enumerable:!0,get:function(){return c.createView}}),Object.defineProperty(t,"utf8ToBytes",{enumerable:!0,get:function(){return c.utf8ToBytes}}),t.bytesToUtf8=function(e){if(!(e instanceof Uint8Array))throw new TypeError("bytesToUtf8 expected Uint8Array, got "+typeof e);return(new TextDecoder).decode(e)},t.hexToBytes=function(e){const t=e.startsWith("0x")?e.substring(2):e;return(0,s.hexToBytes)(t)},t.equalsBytes=function(e,t){if(e.length!==t.length)return!1;for(let r=0;r<e.length;r++)if(e[r]!==t[r])return!1;return!0},t.wrapHash=function(e){return t=>(n.default.bytes(t),e(t))},t.crypto=(()=>{const t="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,r="function"==typeof e.require&&e.require.bind(e);return{node:r&&!t?r("crypto"):void 0,web:t}})()},11083:(e,t,r)=>{var o=r(11568),n=r(88835),s=e.exports;for(var i in o)o.hasOwnProperty(i)&&(s[i]=o[i]);function a(e){if("string"==typeof e&&(e=n.parse(e)),e.protocol||(e.protocol="https:"),"https:"!==e.protocol)throw new Error('Protocol "'+e.protocol+'" not supported. Expected "https:"');return e}s.request=function(e,t){return e=a(e),o.request.call(this,e,t)},s.get=function(e,t){return e=a(e),o.get.call(this,e,t)}},6215:(e,t,r)=>{"use strict";var o=r(48287).Buffer,n=r(65606);Object.defineProperty(t,"__esModule",{value:!0}),t.InvalidStatusCodeError=t.InvalidCertError=void 0;const s=Object.freeze({redirect:!0,expectStatusCode:200,headers:{},full:!1,keepAlive:!0,cors:!1,referrer:!1,sslAllowSelfSigned:!1,_redirectCount:0});class i extends Error{constructor(e,t){super(e),this.fingerprint256=t}}t.InvalidCertError=i;class a extends Error{constructor(e){super(`Request Failed. Status Code: ${e}`),this.statusCode=e}}function c(e,t){if(!t||"text"===t||"json"===t)try{let o=new TextDecoder("utf8",{fatal:!0}).decode(e);if("text"===t)return o;try{return JSON.parse(o)}catch(r){if("json"===t)throw r;return o}}catch(r){if("text"===t||"json"===t)throw r}return e}t.InvalidStatusCodeError=a;let f={};function d(e,t){let n={...s,...t};const u=r(11568),h=r(11083),l=r(78559),{promisify:p}=r(40537),{resolve:m}=r(88835),g=!!/^https/.test(e);let b={method:n.method||"GET",headers:{"Accept-Encoding":"gzip, deflate, br"}};const y=e=>e.replace(/:| /g,"").toLowerCase();if(n.keepAlive){const e={keepAlive:!0,keepAliveMsecs:3e4,maxFreeSockets:1024,maxCachedSessions:1024},t=[g,g&&n.sslPinnedCertificates?.map((e=>y(e))).sort()].join();b.agent=f[t]||(f[t]=new(g?h:u).Agent(e))}"json"===n.type&&(b.headers["Content-Type"]="application/json"),n.data&&(n.method||(b.method="POST"),b.body="json"===n.type?JSON.stringify(n.data):n.data),b.headers={...b.headers,...n.headers},n.sslAllowSelfSigned&&(b.rejectUnauthorized=!1);return new Promise(((t,r)=>{const s=async t=>{if(t&&"DEPTH_ZERO_SELF_SIGNED_CERT"===t.code)try{await d(e,{...n,sslAllowSelfSigned:!0,sslPinnedCertificates:[]})}catch(o){o&&o.fingerprint256&&(t=new i(`Self-signed SSL certificate: ${o.fingerprint256}`,o.fingerprint256))}r(t)},f=(g?h:u).request(e,b,(i=>{i.on("error",s),(async()=>{try{t(await(async t=>{const r=t.statusCode;if(n.redirect&&300<=r&&r<400&&t.headers.location){if(10==n._redirectCount)throw new Error("Request failed. Too much redirects.");return n._redirectCount+=1,await d(m(e,t.headers.location),n)}if(n.expectStatusCode&&r!==n.expectStatusCode)throw t.resume(),new a(r);let s=[];for await(const e of t)s.push(e);let i=o.concat(s);const f=t.headers["content-encoding"];"br"===f&&(i=await p(l.brotliDecompress)(i)),"gzip"!==f&&"deflate"!==f||(i=await p(l.unzip)(i));const u=c(i,n.type);return n.full?{headers:t.headers,status:r,body:u}:u})(i))}catch(s){r(s)}})()}));f.on("error",s);const v=n.sslPinnedCertificates?.map((e=>y(e))),w=e=>{const t=y(e.getPeerCertificate()?.fingerprint256||"");if((t||!e.isSessionReused())&&!v.includes(t))return f.emit("error",new i(`Invalid SSL certificate: ${t} Expected: ${v}`,t)),f.abort()};n.sslPinnedCertificates&&f.on("socket",(e=>{e.listeners("secureConnect").map((e=>(e.name||"").replace("bound ",""))).includes("mfetchSecureConnect")||e.on("secureConnect",w.bind(null,e))})),n.keepAlive&&f.setNoDelay(!0),b.body&&f.write(b.body),f.end()}))}const u=new Set(["Accept","Accept-Language","Content-Language","Content-Type"].map((e=>e.toLowerCase()))),h=new Set(["Accept-Charset","Accept-Encoding","Access-Control-Request-Headers","Access-Control-Request-Method","Connection","Content-Length","Cookie","Cookie2","Date","DNT","Expect","Host","Keep-Alive","Origin","Referer","TE","Trailer","Transfer-Encoding","Upgrade","Via"].map((e=>e.toLowerCase())));async function l(e,t){let r={...s,...t};const o=new Headers;"json"===r.type&&o.set("Content-Type","application/json");let n=new URL(e);if(n.username){const e=btoa(`${n.username}:${n.password}`);o.set("Authorization",`Basic ${e}`),n.username="",n.password=""}e=""+n;for(let s in r.headers){const e=s.toLowerCase();(u.has(e)||r.cors&&!h.has(e))&&o.set(s,r.headers[s])}let i={headers:o,redirect:r.redirect?"follow":"manual"};r.referrer||(i.referrerPolicy="no-referrer"),r.cors&&(i.mode="cors"),r.data&&(r.method||(i.method="POST"),i.body="json"===r.type?JSON.stringify(r.data):r.data);const f=await fetch(e,i);if(r.expectStatusCode&&f.status!==r.expectStatusCode)throw new a(f.status);const d=c(new Uint8Array(await f.arrayBuffer()),r.type);return r.full?{headers:Object.fromEntries(f.headers.entries()),status:f.status,body:d}:d}const p=!!("object"==typeof n&&n.versions&&n.versions.node&&n.versions.v8);t.default=function(e,t){return(p?d:l)(e,t)}},28399:(e,t,r)=>{(t=e.exports=r(45412)).Stream=t,t.Readable=t,t.Writable=r(16708),t.Duplex=r(25382),t.Transform=r(74610),t.PassThrough=r(63600),t.finished=r(86238),t.pipeline=r(57758)},11568:(e,t,r)=>{var o=r(55537),n=r(6917),s=r(57510),i=r(86866),a=r(88835),c=t;c.request=function(e,t){e="string"==typeof e?a.parse(e):s(e);var n=-1===r.g.location.protocol.search(/^https?:$/)?"http:":"",i=e.protocol||n,c=e.hostname||e.host,f=e.port,d=e.path||"/";c&&-1!==c.indexOf(":")&&(c="["+c+"]"),e.url=(c?i+"//"+c:"")+(f?":"+f:"")+d,e.method=(e.method||"GET").toUpperCase(),e.headers=e.headers||{};var u=new o(e);return t&&u.on("response",t),u},c.get=function(e,t){var r=c.request(e,t);return r.end(),r},c.ClientRequest=o,c.IncomingMessage=n.IncomingMessage,c.Agent=function(){},c.Agent.defaultMaxSockets=4,c.globalAgent=new c.Agent,c.STATUS_CODES=i,c.METHODS=["CHECKOUT","CONNECT","COPY","DELETE","GET","HEAD","LOCK","M-SEARCH","MERGE","MKACTIVITY","MKCOL","MOVE","NOTIFY","OPTIONS","PATCH","POST","PROPFIND","PROPPATCH","PURGE","PUT","REPORT","SEARCH","SUBSCRIBE","TRACE","UNLOCK","UNSUBSCRIBE"]},6688:(e,t,r)=>{var o;function n(){if(void 0!==o)return o;if(r.g.XMLHttpRequest){o=new r.g.XMLHttpRequest;try{o.open("GET",r.g.XDomainRequest?"/":"https://example.com")}catch(e){o=null}}else o=null;return o}function s(e){var t=n();if(!t)return!1;try{return t.responseType=e,t.responseType===e}catch(r){}return!1}function i(e){return"function"==typeof e}t.fetch=i(r.g.fetch)&&i(r.g.ReadableStream),t.writableStream=i(r.g.WritableStream),t.abortController=i(r.g.AbortController),t.arraybuffer=t.fetch||s("arraybuffer"),t.msstream=!t.fetch&&s("ms-stream"),t.mozchunkedarraybuffer=!t.fetch&&s("moz-chunked-arraybuffer"),t.overrideMimeType=t.fetch||!!n()&&i(n().overrideMimeType),o=null},55537:(e,t,r)=>{var o=r(48287).Buffer,n=r(65606),s=r(6688),i=r(56698),a=r(6917),c=r(28399),f=a.IncomingMessage,d=a.readyStates;var u=e.exports=function(e){var t,r=this;c.Writable.call(r),r._opts=e,r._body=[],r._headers={},e.auth&&r.setHeader("Authorization","Basic "+o.from(e.auth).toString("base64")),Object.keys(e.headers).forEach((function(t){r.setHeader(t,e.headers[t])}));var n=!0;if("disable-fetch"===e.mode||"requestTimeout"in e&&!s.abortController)n=!1,t=!0;else if("prefer-streaming"===e.mode)t=!1;else if("allow-wrong-content-type"===e.mode)t=!s.overrideMimeType;else{if(e.mode&&"default"!==e.mode&&"prefer-fast"!==e.mode)throw new Error("Invalid value for opts.mode");t=!0}r._mode=function(e,t){return s.fetch&&t?"fetch":s.mozchunkedarraybuffer?"moz-chunked-arraybuffer":s.msstream?"ms-stream":s.arraybuffer&&e?"arraybuffer":"text"}(t,n),r._fetchTimer=null,r._socketTimeout=null,r._socketTimer=null,r.on("finish",(function(){r._onFinish()}))};i(u,c.Writable),u.prototype.setHeader=function(e,t){var r=e.toLowerCase();-1===h.indexOf(r)&&(this._headers[r]={name:e,value:t})},u.prototype.getHeader=function(e){var t=this._headers[e.toLowerCase()];return t?t.value:null},u.prototype.removeHeader=function(e){delete this._headers[e.toLowerCase()]},u.prototype._onFinish=function(){var e=this;if(!e._destroyed){var t=e._opts;"timeout"in t&&0!==t.timeout&&e.setTimeout(t.timeout);var o=e._headers,i=null;"GET"!==t.method&&"HEAD"!==t.method&&(i=new Blob(e._body,{type:(o["content-type"]||{}).value||""}));var a=[];if(Object.keys(o).forEach((function(e){var t=o[e].name,r=o[e].value;Array.isArray(r)?r.forEach((function(e){a.push([t,e])})):a.push([t,r])})),"fetch"===e._mode){var c=null;if(s.abortController){var f=new AbortController;c=f.signal,e._fetchAbortController=f,"requestTimeout"in t&&0!==t.requestTimeout&&(e._fetchTimer=r.g.setTimeout((function(){e.emit("requestTimeout"),e._fetchAbortController&&e._fetchAbortController.abort()}),t.requestTimeout))}r.g.fetch(e._opts.url,{method:e._opts.method,headers:a,body:i||void 0,mode:"cors",credentials:t.withCredentials?"include":"same-origin",signal:c}).then((function(t){e._fetchResponse=t,e._resetTimers(!1),e._connect()}),(function(t){e._resetTimers(!0),e._destroyed||e.emit("error",t)}))}else{var u=e._xhr=new r.g.XMLHttpRequest;try{u.open(e._opts.method,e._opts.url,!0)}catch(h){return void n.nextTick((function(){e.emit("error",h)}))}"responseType"in u&&(u.responseType=e._mode),"withCredentials"in u&&(u.withCredentials=!!t.withCredentials),"text"===e._mode&&"overrideMimeType"in u&&u.overrideMimeType("text/plain; charset=x-user-defined"),"requestTimeout"in t&&(u.timeout=t.requestTimeout,u.ontimeout=function(){e.emit("requestTimeout")}),a.forEach((function(e){u.setRequestHeader(e[0],e[1])})),e._response=null,u.onreadystatechange=function(){switch(u.readyState){case d.LOADING:case d.DONE:e._onXHRProgress()}},"moz-chunked-arraybuffer"===e._mode&&(u.onprogress=function(){e._onXHRProgress()}),u.onerror=function(){e._destroyed||(e._resetTimers(!0),e.emit("error",new Error("XHR error")))};try{u.send(i)}catch(h){return void n.nextTick((function(){e.emit("error",h)}))}}}},u.prototype._onXHRProgress=function(){var e=this;e._resetTimers(!1),function(e){try{var t=e.status;return null!==t&&0!==t}catch(r){return!1}}(e._xhr)&&!e._destroyed&&(e._response||e._connect(),e._response._onXHRProgress(e._resetTimers.bind(e)))},u.prototype._connect=function(){var e=this;e._destroyed||(e._response=new f(e._xhr,e._fetchResponse,e._mode,e._resetTimers.bind(e)),e._response.on("error",(function(t){e.emit("error",t)})),e.emit("response",e._response))},u.prototype._write=function(e,t,r){this._body.push(e),r()},u.prototype._resetTimers=function(e){var t=this;r.g.clearTimeout(t._socketTimer),t._socketTimer=null,e?(r.g.clearTimeout(t._fetchTimer),t._fetchTimer=null):t._socketTimeout&&(t._socketTimer=r.g.setTimeout((function(){t.emit("timeout")}),t._socketTimeout))},u.prototype.abort=u.prototype.destroy=function(e){var t=this;t._destroyed=!0,t._resetTimers(!0),t._response&&(t._response._destroyed=!0),t._xhr?t._xhr.abort():t._fetchAbortController&&t._fetchAbortController.abort(),e&&t.emit("error",e)},u.prototype.end=function(e,t,r){"function"==typeof e&&(r=e,e=void 0),c.Writable.prototype.end.call(this,e,t,r)},u.prototype.setTimeout=function(e,t){var r=this;t&&r.once("timeout",t),r._socketTimeout=e,r._resetTimers(!1)},u.prototype.flushHeaders=function(){},u.prototype.setNoDelay=function(){},u.prototype.setSocketKeepAlive=function(){};var h=["accept-charset","accept-encoding","access-control-request-headers","access-control-request-method","connection","content-length","cookie","cookie2","date","dnt","expect","host","keep-alive","origin","referer","te","trailer","transfer-encoding","upgrade","via"]},6917:(e,t,r)=>{var o=r(65606),n=r(48287).Buffer,s=r(6688),i=r(56698),a=r(28399),c=t.readyStates={UNSENT:0,OPENED:1,HEADERS_RECEIVED:2,LOADING:3,DONE:4},f=t.IncomingMessage=function(e,t,r,i){var c=this;if(a.Readable.call(c),c._mode=r,c.headers={},c.rawHeaders=[],c.trailers={},c.rawTrailers=[],c.on("end",(function(){o.nextTick((function(){c.emit("close")}))})),"fetch"===r){if(c._fetchResponse=t,c.url=t.url,c.statusCode=t.status,c.statusMessage=t.statusText,t.headers.forEach((function(e,t){c.headers[t.toLowerCase()]=e,c.rawHeaders.push(t,e)})),s.writableStream){var f=new WritableStream({write:function(e){return i(!1),new Promise((function(t,r){c._destroyed?r():c.push(n.from(e))?t():c._resumeFetch=t}))},close:function(){i(!0),c._destroyed||c.push(null)},abort:function(e){i(!0),c._destroyed||c.emit("error",e)}});try{return void t.body.pipeTo(f).catch((function(e){i(!0),c._destroyed||c.emit("error",e)}))}catch(l){}}var d=t.body.getReader();!function e(){d.read().then((function(t){c._destroyed||(i(t.done),t.done?c.push(null):(c.push(n.from(t.value)),e()))})).catch((function(e){i(!0),c._destroyed||c.emit("error",e)}))}()}else{if(c._xhr=e,c._pos=0,c.url=e.responseURL,c.statusCode=e.status,c.statusMessage=e.statusText,e.getAllResponseHeaders().split(/\r?\n/).forEach((function(e){var t=e.match(/^([^:]+):\s*(.*)/);if(t){var r=t[1].toLowerCase();"set-cookie"===r?(void 0===c.headers[r]&&(c.headers[r]=[]),c.headers[r].push(t[2])):void 0!==c.headers[r]?c.headers[r]+=", "+t[2]:c.headers[r]=t[2],c.rawHeaders.push(t[1],t[2])}})),c._charset="x-user-defined",!s.overrideMimeType){var u=c.rawHeaders["mime-type"];if(u){var h=u.match(/;\s*charset=([^;])(;|$)/);h&&(c._charset=h[1].toLowerCase())}c._charset||(c._charset="utf-8")}}};i(f,a.Readable),f.prototype._read=function(){var e=this._resumeFetch;e&&(this._resumeFetch=null,e())},f.prototype._onXHRProgress=function(e){var t=this,o=t._xhr,s=null;switch(t._mode){case"text":if((s=o.responseText).length>t._pos){var i=s.substr(t._pos);if("x-user-defined"===t._charset){for(var a=n.alloc(i.length),f=0;f<i.length;f++)a[f]=255&i.charCodeAt(f);t.push(a)}else t.push(i,t._charset);t._pos=s.length}break;case"arraybuffer":if(o.readyState!==c.DONE||!o.response)break;s=o.response,t.push(n.from(new Uint8Array(s)));break;case"moz-chunked-arraybuffer":if(s=o.response,o.readyState!==c.LOADING||!s)break;t.push(n.from(new Uint8Array(s)));break;case"ms-stream":if(s=o.response,o.readyState!==c.LOADING)break;var d=new r.g.MSStreamReader;d.onprogress=function(){d.result.byteLength>t._pos&&(t.push(n.from(new Uint8Array(d.result.slice(t._pos)))),t._pos=d.result.byteLength)},d.onload=function(){e(!0),t.push(null)},d.readAsArrayBuffer(s)}t._xhr.readyState===c.DONE&&"ms-stream"!==t._mode&&(e(!0),t.push(null))}},57510:e=>{e.exports=function(){for(var e={},r=0;r<arguments.length;r++){var o=arguments[r];for(var n in o)t.call(o,n)&&(e[n]=o[n])}return e};var t=Object.prototype.hasOwnProperty},10406:e=>{"use strict";e.exports=JSON.parse('{"name":"goerli","chainId":5,"networkId":5,"defaultHardfork":"merge","consensus":{"type":"poa","algorithm":"clique","clique":{"period":15,"epoch":30000}},"comment":"Cross-client PoA test network","url":"https://github.com/goerli/testnet","genesis":{"timestamp":"0x5c51a607","gasLimit":10485760,"difficulty":1,"nonce":"0x0000000000000000","extraData":"0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},"hardforks":[{"name":"chainstart","block":0,"forkHash":"0xa3f5ab08"},{"name":"homestead","block":0,"forkHash":"0xa3f5ab08"},{"name":"tangerineWhistle","block":0,"forkHash":"0xa3f5ab08"},{"name":"spuriousDragon","block":0,"forkHash":"0xa3f5ab08"},{"name":"byzantium","block":0,"forkHash":"0xa3f5ab08"},{"name":"constantinople","block":0,"forkHash":"0xa3f5ab08"},{"name":"petersburg","block":0,"forkHash":"0xa3f5ab08"},{"name":"istanbul","block":1561651,"forkHash":"0xc25efa5c"},{"name":"berlin","block":4460644,"forkHash":"0x757a1c47"},{"name":"london","block":5062605,"forkHash":"0xb8c6299d"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818","name":"merge","ttd":"10790000","block":7382819,"forkHash":"0xb8c6299d"},{"name":"mergeForkIdTransition","block":null,"forkHash":null},{"name":"shanghai","block":null,"timestamp":"1678832736","forkHash":"0xf9843abf"}],"bootstrapNodes":[{"ip":"51.141.78.53","port":30303,"id":"011f758e6552d105183b1761c5e2dea0111bc20fd5f6422bc7f91e0fabbec9a6595caf6239b37feb773dddd3f87240d99d859431891e4a642cf2a0a9e6cbb98a","location":"","comment":"Upstream bootnode 1"},{"ip":"13.93.54.137","port":30303,"id":"176b9417f511d05b6b2cf3e34b756cf0a7096b3094572a8f6ef4cdcb9d1f9d00683bf0f83347eebdf3b81c3521c2332086d9592802230bf528eaf606a1d9677b","location":"","comment":"Upstream bootnode 2"},{"ip":"94.237.54.114","port":30313,"id":"46add44b9f13965f7b9875ac6b85f016f341012d84f975377573800a863526f4da19ae2c620ec73d11591fa9510e992ecc03ad0751f53cc02f7c7ed6d55c7291","location":"","comment":"Upstream bootnode 3"},{"ip":"18.218.250.66","port":30313,"id":"b5948a2d3e9d486c4d75bf32713221c2bd6cf86463302339299bd227dc2e276cd5a1c7ca4f43a0e9122fe9af884efed563bd2a1fd28661f3b5f5ad7bf1de5949","location":"","comment":"Upstream bootnode 4"},{"ip":"3.11.147.67","port":30303,"id":"a61215641fb8714a373c80edbfa0ea8878243193f57c96eeb44d0bc019ef295abd4e044fd619bfc4c59731a73fb79afe84e9ab6da0c743ceb479cbb6d263fa91","location":"","comment":"Ethereum Foundation bootnode"},{"ip":"51.15.116.226","port":30303,"id":"a869b02cec167211fb4815a82941db2e7ed2936fd90e78619c53eb17753fcf0207463e3419c264e2a1dd8786de0df7e68cf99571ab8aeb7c4e51367ef186b1dd","location":"","comment":"Goerli Initiative bootnode"},{"ip":"51.15.119.157","port":30303,"id":"807b37ee4816ecf407e9112224494b74dd5933625f655962d892f2f0f02d7fbbb3e2a94cf87a96609526f30c998fd71e93e2f53015c558ffc8b03eceaf30ee33","location":"","comment":"Goerli Initiative bootnode"},{"ip":"51.15.119.157","port":40303,"id":"a59e33ccd2b3e52d578f1fbd70c6f9babda2650f0760d6ff3b37742fdcdfdb3defba5d56d315b40c46b70198c7621e63ffa3f987389c7118634b0fefbbdfa7fd","location":"","comment":"Goerli Initiative bootnode"}],"dnsNetworks":["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"]}')},12336:e=>{"use strict";e.exports=JSON.parse('{"name":"mainnet","chainId":1,"networkId":1,"defaultHardfork":"merge","consensus":{"type":"pow","algorithm":"ethash","ethash":{}},"comment":"The Ethereum main chain","url":"https://ethstats.net/","genesis":{"gasLimit":5000,"difficulty":17179869184,"nonce":"0x0000000000000042","extraData":"0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"},"hardforks":[{"name":"chainstart","block":0,"forkHash":"0xfc64ec04"},{"name":"homestead","block":1150000,"forkHash":"0x97c2c34c"},{"name":"dao","block":1920000,"forkHash":"0x91d1f948"},{"name":"tangerineWhistle","block":2463000,"forkHash":"0x7a64da13"},{"name":"spuriousDragon","block":2675000,"forkHash":"0x3edd5b10"},{"name":"byzantium","block":4370000,"forkHash":"0xa00bc324"},{"name":"constantinople","block":7280000,"forkHash":"0x668db0af"},{"name":"petersburg","block":7280000,"forkHash":"0x668db0af"},{"name":"istanbul","block":9069000,"forkHash":"0x879d6e30"},{"name":"muirGlacier","block":9200000,"forkHash":"0xe029e991"},{"name":"berlin","block":12244000,"forkHash":"0x0eb440f6"},{"name":"london","block":12965000,"forkHash":"0xb715077d"},{"name":"arrowGlacier","block":13773000,"forkHash":"0x20c327fc"},{"name":"grayGlacier","block":15050000,"forkHash":"0xf0afd0e3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393","name":"merge","ttd":"58750000000000000000000","block":15537394,"forkHash":"0xf0afd0e3"},{"name":"mergeForkIdTransition","block":null,"forkHash":null},{"name":"shanghai","block":null,"timestamp":"1681338455","forkHash":"0xdce96c2d"}],"bootstrapNodes":[{"ip":"18.138.108.67","port":30303,"id":"d860a01f9722d78051619d1e2351aba3f43f943f6f00718d1b9baa4101932a1f5011f16bb2b1bb35db20d6fe28fa0bf09636d26a87d31de9ec6203eeedb1f666","location":"ap-southeast-1-001","comment":"bootnode-aws-ap-southeast-1-001"},{"ip":"3.209.45.79","port":30303,"id":"22a8232c3abc76a16ae9d6c3b164f98775fe226f0917b0ca871128a74a8e9630b458460865bab457221f1d448dd9791d24c4e5d88786180ac185df813a68d4de","location":"us-east-1-001","comment":"bootnode-aws-us-east-1-001"},{"ip":"65.108.70.101","port":30303,"id":"2b252ab6a1d0f971d9722cb839a42cb81db019ba44c08754628ab4a823487071b5695317c8ccd085219c3a03af063495b2f1da8d18218da2d6a82981b45e6ffc","location":"eu-west-1-001","comment":"bootnode-hetzner-hel"},{"ip":"157.90.35.166","port":30303,"id":"4aeb4ab6c14b23e2c4cfdce879c04b0748a20d8e9b59e25ded2a08143e265c6c25936e74cbc8e641e3312ca288673d91f2f93f8e277de3cfa444ecdaaf982052","location":"eu-central-1-001","comment":"bootnode-hetzner-fsn"}],"dnsNetworks":["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"]}')},17280:e=>{"use strict";e.exports=JSON.parse('{"name":"rinkeby","chainId":4,"networkId":4,"defaultHardfork":"london","consensus":{"type":"poa","algorithm":"clique","clique":{"period":15,"epoch":30000}},"comment":"PoA test network","url":"https://www.rinkeby.io","genesis":{"timestamp":"0x58ee40ba","gasLimit":4700000,"difficulty":1,"nonce":"0x0000000000000000","extraData":"0x52657370656374206d7920617574686f7269746168207e452e436172746d616e42eb768f2244c8811c63729a21a3569731535f067ffc57839b00206d1ad20c69a1981b489f772031b279182d99e65703f0076e4812653aab85fca0f00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"},"hardforks":[{"name":"chainstart","block":0,"forkHash":"0x3b8e0691"},{"name":"homestead","block":1,"forkHash":"0x60949295"},{"name":"tangerineWhistle","block":2,"forkHash":"0x8bde40dd"},{"name":"spuriousDragon","block":3,"forkHash":"0xcb3a64bb"},{"name":"byzantium","block":1035301,"forkHash":"0x8d748b57"},{"name":"constantinople","block":3660663,"forkHash":"0xe49cab14"},{"name":"petersburg","block":4321234,"forkHash":"0xafec6b27"},{"name":"istanbul","block":5435345,"forkHash":"0xcbdb8838"},{"name":"berlin","block":8290928,"forkHash":"0x6910c8bd"},{"name":"london","block":8897988,"forkHash":"0x8e29f2f3"},{"name":"merge","block":null,"forkHash":null},{"name":"shanghai","block":null,"forkHash":null}],"bootstrapNodes":[{"ip":"52.169.42.101","port":30303,"id":"a24ac7c5484ef4ed0c5eb2d36620ba4e4aa13b8c84684e1b4aab0cebea2ae45cb4d375b77eab56516d34bfbd3c1a833fc51296ff084b770b94fb9028c4d25ccf","location":"","comment":"IE"},{"ip":"52.3.158.184","port":30303,"id":"343149e4feefa15d882d9fe4ac7d88f885bd05ebb735e547f12e12080a9fa07c8014ca6fd7f373123488102fe5e34111f8509cf0b7de3f5b44339c9f25e87cb8","location":"","comment":"INFURA"},{"ip":"159.89.28.211","port":30303,"id":"b6b28890b006743680c52e64e0d16db57f28124885595fa03a562be1d2bf0f3a1da297d56b13da25fb992888fd556d4c1a27b1f39d531bde7de1921c90061cc6","location":"","comment":"AKASHA"}],"dnsNetworks":["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.rinkeby.ethdisco.net"]}')},13737:e=>{"use strict";e.exports=JSON.parse('{"name":"ropsten","chainId":3,"networkId":3,"defaultHardfork":"merge","consensus":{"type":"pow","algorithm":"ethash","ethash":{}},"comment":"PoW test network","url":"https://github.com/ethereum/ropsten","genesis":{"gasLimit":16777216,"difficulty":1048576,"nonce":"0x0000000000000042","extraData":"0x3535353535353535353535353535353535353535353535353535353535353535"},"hardforks":[{"name":"chainstart","block":0,"forkHash":"0x30c7ddbc"},{"name":"homestead","block":0,"forkHash":"0x30c7ddbc"},{"name":"tangerineWhistle","block":0,"forkHash":"0x30c7ddbc"},{"name":"spuriousDragon","block":10,"forkHash":"0x63760190"},{"name":"byzantium","block":1700000,"forkHash":"0x3ea159c7"},{"name":"constantinople","block":4230000,"forkHash":"0x97b544f3"},{"name":"petersburg","block":4939394,"forkHash":"0xd6e2149b"},{"name":"istanbul","block":6485846,"forkHash":"0x4bc66396"},{"name":"muirGlacier","block":7117117,"forkHash":"0x6727ef90"},{"name":"berlin","block":9812189,"forkHash":"0xa157d377"},{"name":"london","block":10499401,"forkHash":"0x7119b6b3"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge","name":"merge","ttd":"50000000000000000","block":null,"forkHash":"0x7119b6b3"},{"name":"mergeForkIdTransition","block":null,"forkHash":null},{"name":"shanghai","block":null,"forkHash":null}],"bootstrapNodes":[{"ip":"52.176.7.10","port":30303,"id":"30b7ab30a01c124a6cceca36863ece12c4f5fa68e3ba9b0b51407ccc002eeed3b3102d20a88f1c1d3c3154e2449317b8ef95090e77b312d5cc39354f86d5d606","location":"","comment":"US-Azure geth"},{"ip":"52.176.100.77","port":30303,"id":"865a63255b3bb68023b6bffd5095118fcc13e79dcf014fe4e47e065c350c7cc72af2e53eff895f11ba1bbb6a2b33271c1116ee870f266618eadfc2e78aa7349c","location":"","comment":"US-Azure parity"},{"ip":"52.232.243.152","port":30303,"id":"6332792c4a00e3e4ee0926ed89e0d27ef985424d97b6a45bf0f23e51f0dcb5e66b875777506458aea7af6f9e4ffb69f43f3778ee73c81ed9d34c51c4b16b0b0f","location":"","comment":"Parity"},{"ip":"192.81.208.223","port":30303,"id":"94c15d1b9e2fe7ce56e458b9a3b672ef11894ddedd0c6f247e0f1d3487f52b66208fb4aeb8179fce6e3a749ea93ed147c37976d67af557508d199d9594c35f09","location":"","comment":"@gpip"}],"dnsNetworks":["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.ropsten.ethdisco.net"]}')},14429:e=>{"use strict";e.exports=JSON.parse('{"name":"sepolia","chainId":11155111,"networkId":11155111,"defaultHardfork":"merge","consensus":{"type":"pow","algorithm":"ethash","ethash":{}},"comment":"PoW test network to replace Ropsten","url":"https://github.com/ethereum/go-ethereum/pull/23730","genesis":{"timestamp":"0x6159af19","gasLimit":30000000,"difficulty":131072,"nonce":"0x0000000000000000","extraData":"0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"},"hardforks":[{"name":"chainstart","block":0,"forkHash":"0xfe3366e7"},{"name":"homestead","block":0,"forkHash":"0xfe3366e7"},{"name":"tangerineWhistle","block":0,"forkHash":"0xfe3366e7"},{"name":"spuriousDragon","block":0,"forkHash":"0xfe3366e7"},{"name":"byzantium","block":0,"forkHash":"0xfe3366e7"},{"name":"constantinople","block":0,"forkHash":"0xfe3366e7"},{"name":"petersburg","block":0,"forkHash":"0xfe3366e7"},{"name":"istanbul","block":0,"forkHash":"0xfe3366e7"},{"name":"muirGlacier","block":0,"forkHash":"0xfe3366e7"},{"name":"berlin","block":0,"forkHash":"0xfe3366e7"},{"name":"london","block":0,"forkHash":"0xfe3366e7"},{"//_comment":"The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408","name":"merge","ttd":"17000000000000000","block":1450409,"forkHash":"0xfe3366e7"},{"name":"mergeForkIdTransition","block":1735371,"forkHash":"0xb96cbd13"},{"name":"shanghai","block":null,"timestamp":"1677557088","forkHash":"0xf7f9bc08"}],"bootstrapNodes":[{"ip":"18.168.182.86","port":30303,"id":"9246d00bc8fd1742e5ad2428b80fc4dc45d786283e05ef6edbd9002cbc335d40998444732fbe921cb88e1d2c73d1b1de53bae6a2237996e9bfe14f871baf7066","location":"","comment":"geth"},{"ip":"52.14.151.177","port":30303,"id":"ec66ddcf1a974950bd4c782789a7e04f8aa7110a72569b6e65fcd51e937e74eed303b1ea734e4d19cfaec9fbff9b6ee65bf31dcb50ba79acce9dd63a6aca61c7","location":"","comment":"besu"},{"ip":"165.22.196.173","port":30303,"id":"ce970ad2e9daa9e14593de84a8b49da3d54ccfdf83cbc4fe519cb8b36b5918ed4eab087dedd4a62479b8d50756b492d5f762367c8d20329a7854ec01547568a6","location":"","comment":"EF"},{"ip":"65.108.95.67","port":30303,"id":"075503b13ed736244896efcde2a992ec0b451357d46cb7a8132c0384721742597fc8f0d91bbb40bb52e7d6e66728d36a1fda09176294e4a30cfac55dcce26bc6","location":"","comment":"lodestar"}],"dnsNetworks":["enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"]}')},42973:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-1153","number":1153,"comment":"Transient Storage","url":"https://eips.ethereum.org/EIPS/eip-1153","status":"Review","minimumHardfork":"chainstart","requiredEIPs":[],"gasConfig":{},"gasPrices":{"tstore":{"v":100,"d":"Base fee of the TSTORE opcode"},"tload":{"v":100,"d":"Base fee of the TLOAD opcode"}},"vm":{},"pow":{}}')},23031:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-1559","number":1559,"comment":"Fee market change for ETH 1.0 chain","url":"https://eips.ethereum.org/EIPS/eip-1559","status":"Final","minimumHardfork":"berlin","requiredEIPs":[2930],"gasConfig":{"baseFeeMaxChangeDenominator":{"v":8,"d":"Maximum base fee change denominator"},"elasticityMultiplier":{"v":2,"d":"Maximum block gas target elasticity"},"initialBaseFee":{"v":1000000000,"d":"Initial base fee on first EIP1559 block"}},"gasPrices":{},"vm":{},"pow":{}}')},14918:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2315","number":2315,"comment":"Simple subroutines for the EVM","url":"https://eips.ethereum.org/EIPS/eip-2315","status":"Draft","minimumHardfork":"istanbul","gasConfig":{},"gasPrices":{"beginsub":{"v":2,"d":"Base fee of the BEGINSUB opcode"},"returnsub":{"v":5,"d":"Base fee of the RETURNSUB opcode"},"jumpsub":{"v":10,"d":"Base fee of the JUMPSUB opcode"}},"vm":{},"pow":{}}')},86284:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2537","number":2537,"comment":"BLS12-381 precompiles","url":"https://eips.ethereum.org/EIPS/eip-2537","status":"Draft","minimumHardfork":"chainstart","gasConfig":{},"gasPrices":{"Bls12381G1AddGas":{"v":600,"d":"Gas cost of a single BLS12-381 G1 addition precompile-call"},"Bls12381G1MulGas":{"v":12000,"d":"Gas cost of a single BLS12-381 G1 multiplication precompile-call"},"Bls12381G2AddGas":{"v":4500,"d":"Gas cost of a single BLS12-381 G2 addition precompile-call"},"Bls12381G2MulGas":{"v":55000,"d":"Gas cost of a single BLS12-381 G2 multiplication precompile-call"},"Bls12381PairingBaseGas":{"v":115000,"d":"Base gas cost of BLS12-381 pairing check"},"Bls12381PairingPerPairGas":{"v":23000,"d":"Per-pair gas cost of BLS12-381 pairing check"},"Bls12381MapG1Gas":{"v":5500,"d":"Gas cost of BLS12-381 map field element to G1"},"Bls12381MapG2Gas":{"v":110000,"d":"Gas cost of BLS12-381 map field element to G2"},"Bls12381MultiExpGasDiscount":{"v":[[1,1200],[2,888],[3,764],[4,641],[5,594],[6,547],[7,500],[8,453],[9,438],[10,423],[11,408],[12,394],[13,379],[14,364],[15,349],[16,334],[17,330],[18,326],[19,322],[20,318],[21,314],[22,310],[23,306],[24,302],[25,298],[26,294],[27,289],[28,285],[29,281],[30,277],[31,273],[32,269],[33,268],[34,266],[35,265],[36,263],[37,262],[38,260],[39,259],[40,257],[41,256],[42,254],[43,253],[44,251],[45,250],[46,248],[47,247],[48,245],[49,244],[50,242],[51,241],[52,239],[53,238],[54,236],[55,235],[56,233],[57,232],[58,231],[59,229],[60,228],[61,226],[62,225],[63,223],[64,222],[65,221],[66,220],[67,219],[68,219],[69,218],[70,217],[71,216],[72,216],[73,215],[74,214],[75,213],[76,213],[77,212],[78,211],[79,211],[80,210],[81,209],[82,208],[83,208],[84,207],[85,206],[86,205],[87,205],[88,204],[89,203],[90,202],[91,202],[92,201],[93,200],[94,199],[95,199],[96,198],[97,197],[98,196],[99,196],[100,195],[101,194],[102,193],[103,193],[104,192],[105,191],[106,191],[107,190],[108,189],[109,188],[110,188],[111,187],[112,186],[113,185],[114,185],[115,184],[116,183],[117,182],[118,182],[119,181],[120,180],[121,179],[122,179],[123,178],[124,177],[125,176],[126,176],[127,175],[128,174]],"d":"Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"}},"vm":{},"pow":{}}')},78315:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2565","number":2565,"comment":"ModExp gas cost","url":"https://eips.ethereum.org/EIPS/eip-2565","status":"Final","minimumHardfork":"byzantium","gasConfig":{},"gasPrices":{"modexpGquaddivisor":{"v":3,"d":"Gquaddivisor from modexp precompile for gas calculation"}},"vm":{},"pow":{}}')},61417:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2718","comment":"Typed Transaction Envelope","url":"https://eips.ethereum.org/EIPS/eip-2718","status":"Final","minimumHardfork":"chainstart","gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},76967:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2929","comment":"Gas cost increases for state access opcodes","url":"https://eips.ethereum.org/EIPS/eip-2929","status":"Final","minimumHardfork":"chainstart","gasConfig":{},"gasPrices":{"coldsload":{"v":2100,"d":"Gas cost of the first read of storage from a given location (per transaction)"},"coldaccountaccess":{"v":2600,"d":"Gas cost of the first read of a given address (per transaction)"},"warmstorageread":{"v":100,"d":"Gas cost of reading storage locations which have already loaded \'cold\'"},"sstoreCleanGasEIP2200":{"v":2900,"d":"Once per SSTORE operation from clean non-zero to something else"},"sstoreNoopGasEIP2200":{"v":100,"d":"Once per SSTORE operation if the value doesn\'t change"},"sstoreDirtyGasEIP2200":{"v":100,"d":"Once per SSTORE operation if a dirty value is changed"},"sstoreInitRefundEIP2200":{"v":19900,"d":"Once per SSTORE operation for resetting to the original zero value"},"sstoreCleanRefundEIP2200":{"v":4900,"d":"Once per SSTORE operation for resetting to the original non-zero value"},"call":{"v":0,"d":"Base fee of the CALL opcode"},"callcode":{"v":0,"d":"Base fee of the CALLCODE opcode"},"delegatecall":{"v":0,"d":"Base fee of the DELEGATECALL opcode"},"staticcall":{"v":0,"d":"Base fee of the STATICCALL opcode"},"balance":{"v":0,"d":"Base fee of the BALANCE opcode"},"extcodesize":{"v":0,"d":"Base fee of the EXTCODESIZE opcode"},"extcodecopy":{"v":0,"d":"Base fee of the EXTCODECOPY opcode"},"extcodehash":{"v":0,"d":"Base fee of the EXTCODEHASH opcode"},"sload":{"v":0,"d":"Base fee of the SLOAD opcode"},"sstore":{"v":0,"d":"Base fee of the SSTORE opcode"}},"vm":{},"pow":{}}')},67577:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-2930","comment":"Optional access lists","url":"https://eips.ethereum.org/EIPS/eip-2930","status":"Final","minimumHardfork":"istanbul","requiredEIPs":[2718,2929],"gasConfig":{},"gasPrices":{"accessListStorageKeyCost":{"v":1900,"d":"Gas cost per storage key in an Access List transaction"},"accessListAddressCost":{"v":2400,"d":"Gas cost per storage key in an Access List transaction"}},"vm":{},"pow":{}}')},46475:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3074","number":3074,"comment":"AUTH and AUTHCALL opcodes","url":"https://eips.ethereum.org/EIPS/eip-3074","status":"Review","minimumHardfork":"london","gasConfig":{},"gasPrices":{"auth":{"v":3100,"d":"Gas cost of the AUTH opcode"},"authcall":{"v":0,"d":"Gas cost of the AUTHCALL opcode"},"authcallValueTransfer":{"v":6700,"d":"Paid for CALL when the value transfer is non-zero"}},"vm":{},"pow":{}}')},48542:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3198","number":3198,"comment":"BASEFEE opcode","url":"https://eips.ethereum.org/EIPS/eip-3198","status":"Final","minimumHardfork":"london","gasConfig":{},"gasPrices":{"basefee":{"v":2,"d":"Gas cost of the BASEFEE opcode"}},"vm":{},"pow":{}}')},77294:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3529","comment":"Reduction in refunds","url":"https://eips.ethereum.org/EIPS/eip-3529","status":"Final","minimumHardfork":"berlin","requiredEIPs":[2929],"gasConfig":{"maxRefundQuotient":{"v":5,"d":"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},"gasPrices":{"selfdestructRefund":{"v":0,"d":"Refunded following a selfdestruct operation"},"sstoreClearRefundEIP2200":{"v":4800,"d":"Once per SSTORE operation for clearing an originally existing storage slot"}},"vm":{},"pow":{}}')},331:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3540","number":3540,"comment":"EVM Object Format (EOF) v1","url":"https://eips.ethereum.org/EIPS/eip-3540","status":"Review","minimumHardfork":"london","requiredEIPs":[3541],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},91464:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3541","comment":"Reject new contracts starting with the 0xEF byte","url":"https://eips.ethereum.org/EIPS/eip-3541","status":"Final","minimumHardfork":"berlin","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},44298:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3554","comment":"Reduction in refunds","url":"Difficulty Bomb Delay to December 1st 2021","status":"Final","minimumHardfork":"muirGlacier","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{"difficultyBombDelay":{"v":9500000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},45515:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3607","number":3607,"comment":"Reject transactions from senders with deployed code","url":"https://eips.ethereum.org/EIPS/eip-3607","status":"Final","minimumHardfork":"chainstart","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},77436:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3651","number":3198,"comment":"Warm COINBASE","url":"https://eips.ethereum.org/EIPS/eip-3651","status":"Review","minimumHardfork":"london","requiredEIPs":[2929],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},75569:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3670","number":3670,"comment":"EOF - Code Validation","url":"https://eips.ethereum.org/EIPS/eip-3670","status":"Review","minimumHardfork":"london","requiredEIPs":[3540],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},31770:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3675","number":3675,"comment":"Upgrade consensus to Proof-of-Stake","url":"https://eips.ethereum.org/EIPS/eip-3675","status":"Final","minimumHardfork":"london","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},57610:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3855","number":3855,"comment":"PUSH0 instruction","url":"https://eips.ethereum.org/EIPS/eip-3855","status":"Review","minimumHardfork":"chainstart","requiredEIPs":[],"gasConfig":{},"gasPrices":{"push0":{"v":2,"d":"Base fee of the PUSH0 opcode"}},"vm":{},"pow":{}}')},58842:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-3860","number":3860,"comment":"Limit and meter initcode","url":"https://eips.ethereum.org/EIPS/eip-3860","status":"Review","minimumHardfork":"spuriousDragon","requiredEIPs":[],"gasConfig":{},"gasPrices":{"initCodeWordCost":{"v":2,"d":"Gas to pay for each word (32 bytes) of initcode when creating a contract"}},"vm":{"maxInitCodeSize":{"v":49152,"d":"Maximum length of initialization code when creating a contract"}},"pow":{}}')},86865:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-4345","number":4345,"comment":"Difficulty Bomb Delay to June 2022","url":"https://eips.ethereum.org/EIPS/eip-4345","status":"Final","minimumHardfork":"london","gasConfig":{},"gasPrices":{},"vm":{},"pow":{"difficultyBombDelay":{"v":10700000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},75160:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-4399","number":4399,"comment":"Supplant DIFFICULTY opcode with PREVRANDAO","url":"https://eips.ethereum.org/EIPS/eip-4399","status":"Review","minimumHardfork":"london","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},76111:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-4844","number":4844,"comment":"Shard Blob Transactions","url":"https://eips.ethereum.org/EIPS/eip-4844","status":"Draft","minimumHardfork":"merge","requiredEIPs":[1559,2718,2930,4895],"gasConfig":{"dataGasPerBlob":{"v":131072,"d":"The base fee for data gas per blob"},"targetDataGasPerBlock":{"v":262144,"d":"The target data gas consumed per block"},"maxDataGasPerBlock":{"v":524288,"d":"The max data gas allowable per block"},"dataGasPriceUpdateFraction":{"v":2225652,"d":"The denominator used in the exponential when calculating a data gas price"}},"gasPrices":{"simpleGasPerBlob":{"v":12000,"d":"The basic gas fee for each blob"},"minDataGasPrice":{"v":1,"d":"The minimum fee per data gas"},"kzgPointEvaluationGasPrecompilePrice":{"v":50000,"d":"The fee associated with the point evaluation precompile"},"datahash":{"v":3,"d":"Base fee of the DATAHASH opcode"}},"sharding":{"blobCommitmentVersionKzg":{"v":1,"d":"The number indicated a versioned hash is a KZG commitment"},"fieldElementsPerBlob":{"v":4096,"d":"The number of field elements allowed per blob"}},"vm":{},"pow":{}}')},63025:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-4895","number":4895,"comment":"Beacon chain push withdrawals as operations","url":"https://eips.ethereum.org/EIPS/eip-4895","status":"Review","minimumHardfork":"merge","requiredEIPs":[],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},62047:e=>{"use strict";e.exports=JSON.parse('{"name":"EIP-5133","number":5133,"comment":"Delaying Difficulty Bomb to mid-September 2022","url":"https://eips.ethereum.org/EIPS/eip-5133","status":"Draft","minimumHardfork":"grayGlacier","gasConfig":{},"gasPrices":{},"vm":{},"pow":{"difficultyBombDelay":{"v":11400000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},94164:e=>{"use strict";e.exports=JSON.parse('{"name":"arrowGlacier","comment":"HF to delay the difficulty bomb","url":"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md","status":"Final","eips":[4345],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},72094:e=>{"use strict";e.exports=JSON.parse('{"name":"berlin","comment":"HF targeted for July 2020 following the Muir Glacier HF","url":"https://eips.ethereum.org/EIPS/eip-2070","status":"Final","eips":[2565,2929,2718,2930]}')},13821:e=>{"use strict";e.exports=JSON.parse('{"name":"byzantium","comment":"Hardfork with new precompiles, instructions and other protocol changes","url":"https://eips.ethereum.org/EIPS/eip-609","status":"Final","gasConfig":{},"gasPrices":{"modexpGquaddivisor":{"v":20,"d":"Gquaddivisor from modexp precompile for gas calculation"},"ecAdd":{"v":500,"d":"Gas costs for curve addition precompile"},"ecMul":{"v":40000,"d":"Gas costs for curve multiplication precompile"},"ecPairing":{"v":100000,"d":"Base gas costs for curve pairing precompile"},"ecPairingWord":{"v":80000,"d":"Gas costs regarding curve pairing precompile input length"},"revert":{"v":0,"d":"Base fee of the REVERT opcode"},"staticcall":{"v":700,"d":"Base fee of the STATICCALL opcode"},"returndatasize":{"v":2,"d":"Base fee of the RETURNDATASIZE opcode"},"returndatacopy":{"v":3,"d":"Base fee of the RETURNDATACOPY opcode"}},"vm":{},"pow":{"minerReward":{"v":"3000000000000000000","d":"the amount a miner get rewarded for mining a block"},"difficultyBombDelay":{"v":3000000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},61497:e=>{"use strict";e.exports=JSON.parse('{"name":"chainstart","comment":"Start of the Ethereum main chain","url":"","status":"","gasConfig":{"minGasLimit":{"v":5000,"d":"Minimum the gas limit may ever be"},"gasLimitBoundDivisor":{"v":1024,"d":"The bound divisor of the gas limit, used in update calculations"},"maxRefundQuotient":{"v":2,"d":"Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"}},"gasPrices":{"base":{"v":2,"d":"Gas base cost, used e.g. for ChainID opcode (Istanbul)"},"tierStep":{"v":[0,2,3,5,8,10,20],"d":"Once per operation, for a selection of them"},"exp":{"v":10,"d":"Base fee of the EXP opcode"},"expByte":{"v":10,"d":"Times ceil(log256(exponent)) for the EXP instruction"},"sha3":{"v":30,"d":"Base fee of the SHA3 opcode"},"sha3Word":{"v":6,"d":"Once per word of the SHA3 operation\'s data"},"sload":{"v":50,"d":"Base fee of the SLOAD opcode"},"sstoreSet":{"v":20000,"d":"Once per SSTORE operation if the zeroness changes from zero"},"sstoreReset":{"v":5000,"d":"Once per SSTORE operation if the zeroness does not change from zero"},"sstoreRefund":{"v":15000,"d":"Once per SSTORE operation if the zeroness changes to zero"},"jumpdest":{"v":1,"d":"Base fee of the JUMPDEST opcode"},"log":{"v":375,"d":"Base fee of the LOG opcode"},"logData":{"v":8,"d":"Per byte in a LOG* operation\'s data"},"logTopic":{"v":375,"d":"Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"},"create":{"v":32000,"d":"Base fee of the CREATE opcode"},"call":{"v":40,"d":"Base fee of the CALL opcode"},"callStipend":{"v":2300,"d":"Free gas given at beginning of call"},"callValueTransfer":{"v":9000,"d":"Paid for CALL when the value transfor is non-zero"},"callNewAccount":{"v":25000,"d":"Paid for CALL when the destination address didn\'t exist prior"},"selfdestructRefund":{"v":24000,"d":"Refunded following a selfdestruct operation"},"memory":{"v":3,"d":"Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"},"quadCoeffDiv":{"v":512,"d":"Divisor for the quadratic particle of the memory cost equation"},"createData":{"v":200,"d":""},"tx":{"v":21000,"d":"Per transaction. NOTE: Not payable on data of calls between transactions"},"txCreation":{"v":32000,"d":"The cost of creating a contract via tx"},"txDataZero":{"v":4,"d":"Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"},"txDataNonZero":{"v":68,"d":"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},"copy":{"v":3,"d":"Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"},"ecRecover":{"v":3000,"d":""},"sha256":{"v":60,"d":""},"sha256Word":{"v":12,"d":""},"ripemd160":{"v":600,"d":""},"ripemd160Word":{"v":120,"d":""},"identity":{"v":15,"d":""},"identityWord":{"v":3,"d":""},"stop":{"v":0,"d":"Base fee of the STOP opcode"},"add":{"v":3,"d":"Base fee of the ADD opcode"},"mul":{"v":5,"d":"Base fee of the MUL opcode"},"sub":{"v":3,"d":"Base fee of the SUB opcode"},"div":{"v":5,"d":"Base fee of the DIV opcode"},"sdiv":{"v":5,"d":"Base fee of the SDIV opcode"},"mod":{"v":5,"d":"Base fee of the MOD opcode"},"smod":{"v":5,"d":"Base fee of the SMOD opcode"},"addmod":{"v":8,"d":"Base fee of the ADDMOD opcode"},"mulmod":{"v":8,"d":"Base fee of the MULMOD opcode"},"signextend":{"v":5,"d":"Base fee of the SIGNEXTEND opcode"},"lt":{"v":3,"d":"Base fee of the LT opcode"},"gt":{"v":3,"d":"Base fee of the GT opcode"},"slt":{"v":3,"d":"Base fee of the SLT opcode"},"sgt":{"v":3,"d":"Base fee of the SGT opcode"},"eq":{"v":3,"d":"Base fee of the EQ opcode"},"iszero":{"v":3,"d":"Base fee of the ISZERO opcode"},"and":{"v":3,"d":"Base fee of the AND opcode"},"or":{"v":3,"d":"Base fee of the OR opcode"},"xor":{"v":3,"d":"Base fee of the XOR opcode"},"not":{"v":3,"d":"Base fee of the NOT opcode"},"byte":{"v":3,"d":"Base fee of the BYTE opcode"},"address":{"v":2,"d":"Base fee of the ADDRESS opcode"},"balance":{"v":20,"d":"Base fee of the BALANCE opcode"},"origin":{"v":2,"d":"Base fee of the ORIGIN opcode"},"caller":{"v":2,"d":"Base fee of the CALLER opcode"},"callvalue":{"v":2,"d":"Base fee of the CALLVALUE opcode"},"calldataload":{"v":3,"d":"Base fee of the CALLDATALOAD opcode"},"calldatasize":{"v":2,"d":"Base fee of the CALLDATASIZE opcode"},"calldatacopy":{"v":3,"d":"Base fee of the CALLDATACOPY opcode"},"codesize":{"v":2,"d":"Base fee of the CODESIZE opcode"},"codecopy":{"v":3,"d":"Base fee of the CODECOPY opcode"},"gasprice":{"v":2,"d":"Base fee of the GASPRICE opcode"},"extcodesize":{"v":20,"d":"Base fee of the EXTCODESIZE opcode"},"extcodecopy":{"v":20,"d":"Base fee of the EXTCODECOPY opcode"},"blockhash":{"v":20,"d":"Base fee of the BLOCKHASH opcode"},"coinbase":{"v":2,"d":"Base fee of the COINBASE opcode"},"timestamp":{"v":2,"d":"Base fee of the TIMESTAMP opcode"},"number":{"v":2,"d":"Base fee of the NUMBER opcode"},"difficulty":{"v":2,"d":"Base fee of the DIFFICULTY opcode"},"gaslimit":{"v":2,"d":"Base fee of the GASLIMIT opcode"},"pop":{"v":2,"d":"Base fee of the POP opcode"},"mload":{"v":3,"d":"Base fee of the MLOAD opcode"},"mstore":{"v":3,"d":"Base fee of the MSTORE opcode"},"mstore8":{"v":3,"d":"Base fee of the MSTORE8 opcode"},"sstore":{"v":0,"d":"Base fee of the SSTORE opcode"},"jump":{"v":8,"d":"Base fee of the JUMP opcode"},"jumpi":{"v":10,"d":"Base fee of the JUMPI opcode"},"pc":{"v":2,"d":"Base fee of the PC opcode"},"msize":{"v":2,"d":"Base fee of the MSIZE opcode"},"gas":{"v":2,"d":"Base fee of the GAS opcode"},"push":{"v":3,"d":"Base fee of the PUSH opcode"},"dup":{"v":3,"d":"Base fee of the DUP opcode"},"swap":{"v":3,"d":"Base fee of the SWAP opcode"},"callcode":{"v":40,"d":"Base fee of the CALLCODE opcode"},"return":{"v":0,"d":"Base fee of the RETURN opcode"},"invalid":{"v":0,"d":"Base fee of the INVALID opcode"},"selfdestruct":{"v":0,"d":"Base fee of the SELFDESTRUCT opcode"}},"vm":{"stackLimit":{"v":1024,"d":"Maximum size of VM stack allowed"},"callCreateDepth":{"v":1024,"d":"Maximum depth of call/create stack"},"maxExtraDataSize":{"v":32,"d":"Maximum size extra data may be after Genesis"}},"pow":{"minimumDifficulty":{"v":131072,"d":"The minimum that the difficulty may ever be"},"difficultyBoundDivisor":{"v":2048,"d":"The bound divisor of the difficulty, used in the update calculations"},"durationLimit":{"v":13,"d":"The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"},"epochDuration":{"v":30000,"d":"Duration between proof-of-work epochs"},"timebombPeriod":{"v":100000,"d":"Exponential difficulty timebomb period"},"minerReward":{"v":"5000000000000000000","d":"the amount a miner get rewarded for mining a block"},"difficultyBombDelay":{"v":0,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},88593:e=>{"use strict";e.exports=JSON.parse('{"name":"constantinople","comment":"Postponed hardfork including EIP-1283 (SSTORE gas metering changes)","url":"https://eips.ethereum.org/EIPS/eip-1013","status":"Final","gasConfig":{},"gasPrices":{"netSstoreNoopGas":{"v":200,"d":"Once per SSTORE operation if the value doesn\'t change"},"netSstoreInitGas":{"v":20000,"d":"Once per SSTORE operation from clean zero"},"netSstoreCleanGas":{"v":5000,"d":"Once per SSTORE operation from clean non-zero"},"netSstoreDirtyGas":{"v":200,"d":"Once per SSTORE operation from dirty"},"netSstoreClearRefund":{"v":15000,"d":"Once per SSTORE operation for clearing an originally existing storage slot"},"netSstoreResetRefund":{"v":4800,"d":"Once per SSTORE operation for resetting to the original non-zero value"},"netSstoreResetClearRefund":{"v":19800,"d":"Once per SSTORE operation for resetting to the original zero value"},"shl":{"v":3,"d":"Base fee of the SHL opcode"},"shr":{"v":3,"d":"Base fee of the SHR opcode"},"sar":{"v":3,"d":"Base fee of the SAR opcode"},"extcodehash":{"v":400,"d":"Base fee of the EXTCODEHASH opcode"},"create2":{"v":32000,"d":"Base fee of the CREATE2 opcode"}},"vm":{},"pow":{"minerReward":{"v":"2000000000000000000","d":"The amount a miner gets rewarded for mining a block"},"difficultyBombDelay":{"v":5000000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},27582:e=>{"use strict";e.exports=JSON.parse('{"name":"dao","comment":"DAO rescue hardfork","url":"https://eips.ethereum.org/EIPS/eip-779","status":"Final","gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},62386:e=>{"use strict";e.exports=JSON.parse('{"name":"grayGlacier","comment":"Delaying the difficulty bomb to Mid September 2022","url":"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md","status":"Draft","eips":[5133],"gasConfig":{},"gasPrices":{},"vm":{},"pow":{}}')},9448:e=>{"use strict";e.exports=JSON.parse('{"name":"homestead","comment":"Homestead hardfork with protocol and network changes","url":"https://eips.ethereum.org/EIPS/eip-606","status":"Final","gasConfig":{},"gasPrices":{"delegatecall":{"v":40,"d":"Base fee of the DELEGATECALL opcode"}},"vm":{},"pow":{}}')},77e3:e=>{"use strict";e.exports=JSON.parse('{"name":"istanbul","comment":"HF targeted for December 2019 following the Constantinople/Petersburg HF","url":"https://eips.ethereum.org/EIPS/eip-1679","status":"Final","gasConfig":{},"gasPrices":{"blake2Round":{"v":1,"d":"Gas cost per round for the Blake2 F precompile"},"ecAdd":{"v":150,"d":"Gas costs for curve addition precompile"},"ecMul":{"v":6000,"d":"Gas costs for curve multiplication precompile"},"ecPairing":{"v":45000,"d":"Base gas costs for curve pairing precompile"},"ecPairingWord":{"v":34000,"d":"Gas costs regarding curve pairing precompile input length"},"txDataNonZero":{"v":16,"d":"Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"},"sstoreSentryGasEIP2200":{"v":2300,"d":"Minimum gas required to be present for an SSTORE call, not consumed"},"sstoreNoopGasEIP2200":{"v":800,"d":"Once per SSTORE operation if the value doesn\'t change"},"sstoreDirtyGasEIP2200":{"v":800,"d":"Once per SSTORE operation if a dirty value is changed"},"sstoreInitGasEIP2200":{"v":20000,"d":"Once per SSTORE operation from clean zero to non-zero"},"sstoreInitRefundEIP2200":{"v":19200,"d":"Once per SSTORE operation for resetting to the original zero value"},"sstoreCleanGasEIP2200":{"v":5000,"d":"Once per SSTORE operation from clean non-zero to something else"},"sstoreCleanRefundEIP2200":{"v":4200,"d":"Once per SSTORE operation for resetting to the original non-zero value"},"sstoreClearRefundEIP2200":{"v":15000,"d":"Once per SSTORE operation for clearing an originally existing storage slot"},"balance":{"v":700,"d":"Base fee of the BALANCE opcode"},"extcodehash":{"v":700,"d":"Base fee of the EXTCODEHASH opcode"},"chainid":{"v":2,"d":"Base fee of the CHAINID opcode"},"selfbalance":{"v":5,"d":"Base fee of the SELFBALANCE opcode"},"sload":{"v":800,"d":"Base fee of the SLOAD opcode"}},"vm":{},"pow":{}}')},68816:e=>{"use strict";e.exports=JSON.parse('{"name":"london","comment":"HF targeted for July 2021 following the Berlin fork","url":"https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md","status":"Final","eips":[1559,3198,3529,3541]}')},69430:e=>{"use strict";e.exports=JSON.parse('{"name":"merge","comment":"Hardfork to upgrade the consensus mechanism to Proof-of-Stake","url":"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md","status":"Final","consensus":{"type":"pos","algorithm":"casper","casper":{}},"eips":[3675,4399]}')},69828:e=>{"use strict";e.exports=JSON.parse('{"name":"mergeForkIdTransition","comment":"Pre-merge hardfork to fork off non-upgraded clients","url":"https://eips.ethereum.org/EIPS/eip-3675","status":"Draft","eips":[]}')},99752:e=>{"use strict";e.exports=JSON.parse('{"name":"muirGlacier","comment":"HF to delay the difficulty bomb","url":"https://eips.ethereum.org/EIPS/eip-2384","status":"Final","gasConfig":{},"gasPrices":{},"vm":{},"pow":{"difficultyBombDelay":{"v":9000000,"d":"the amount of blocks to delay the difficulty bomb with"}}}')},11683:e=>{"use strict";e.exports=JSON.parse('{"name":"petersburg","comment":"Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople","url":"https://eips.ethereum.org/EIPS/eip-1716","status":"Final","gasConfig":{},"gasPrices":{"netSstoreNoopGas":{"v":null,"d":"Removed along EIP-1283"},"netSstoreInitGas":{"v":null,"d":"Removed along EIP-1283"},"netSstoreCleanGas":{"v":null,"d":"Removed along EIP-1283"},"netSstoreDirtyGas":{"v":null,"d":"Removed along EIP-1283"},"netSstoreClearRefund":{"v":null,"d":"Removed along EIP-1283"},"netSstoreResetRefund":{"v":null,"d":"Removed along EIP-1283"},"netSstoreResetClearRefund":{"v":null,"d":"Removed along EIP-1283"}},"vm":{},"pow":{}}')},62783:e=>{"use strict";e.exports=JSON.parse('{"name":"shanghai","comment":"Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode","url":"https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md","status":"Final","eips":[3651,3855,3860,4895]}')},49302:e=>{"use strict";e.exports=JSON.parse('{"name":"shardingFork","comment":"Internal hardfork to test proto-danksharding (do not use in production)","url":"https://eips.ethereum.org/EIPS/eip-4844","status":"Experimental","eips":[4844]}')},53521:e=>{"use strict";e.exports=JSON.parse('{"name":"spuriousDragon","comment":"HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit","url":"https://eips.ethereum.org/EIPS/eip-607","status":"Final","gasConfig":{},"gasPrices":{"expByte":{"v":50,"d":"Times ceil(log256(exponent)) for the EXP instruction"}},"vm":{"maxCodeSize":{"v":24576,"d":"Maximum length of contract code"}},"pow":{}}')},53725:e=>{"use strict";e.exports=JSON.parse('{"name":"tangerineWhistle","comment":"Hardfork with gas cost changes for IO-heavy operations","url":"https://eips.ethereum.org/EIPS/eip-608","status":"Final","gasConfig":{},"gasPrices":{"sload":{"v":200,"d":"Once per SLOAD operation"},"call":{"v":700,"d":"Once per CALL operation & message call transaction"},"extcodesize":{"v":700,"d":"Base fee of the EXTCODESIZE opcode"},"extcodecopy":{"v":700,"d":"Base fee of the EXTCODECOPY opcode"},"balance":{"v":400,"d":"Base fee of the BALANCE opcode"},"delegatecall":{"v":700,"d":"Base fee of the DELEGATECALL opcode"},"callcode":{"v":700,"d":"Base fee of the CALLCODE opcode"},"selfdestruct":{"v":5000,"d":"Base fee of the SELFDESTRUCT opcode"}},"vm":{},"pow":{}}')}}]);